<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/v.jpeg?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/v.jpeg?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="Vee Zhang" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="&amp;emsp;&amp;emsp;上一篇 【golang源码分析】之GPM概述 ，我们介绍 GPM 的一些基础概念，这里将是重点，梳理 GMP 的调度流程。其实在 【golang源码分析】之启动追踪 中以及梳理了一下启动流程，涉及到的地方，这里会简要的过一下。初始化程序的入口12345678910// src/runtime/rt0_linux_amd64.s//  linux amd64 系统的启动函数T">
<meta property="og:type" content="article">
<meta property="og:title" content="【golang源码分析】之GPM调度">
<meta property="og:url" content="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/index.html">
<meta property="og:site_name" content="Vee Zhang">
<meta property="og:description" content="&amp;emsp;&amp;emsp;上一篇 【golang源码分析】之GPM概述 ，我们介绍 GPM 的一些基础概念，这里将是重点，梳理 GMP 的调度流程。其实在 【golang源码分析】之启动追踪 中以及梳理了一下启动流程，涉及到的地方，这里会简要的过一下。初始化程序的入口12345678910// src/runtime/rt0_linux_amd64.s//  linux amd64 系统的启动函数T">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/GPM%E8%B0%83%E5%BA%A6.jpg">
<meta property="og:image" content="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/M%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg">
<meta property="og:image" content="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/P%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg">
<meta property="og:image" content="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/G%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg">
<meta property="og:updated_time" content="2020-05-15T08:26:44.374Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【golang源码分析】之GPM调度">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;上一篇 【golang源码分析】之GPM概述 ，我们介绍 GPM 的一些基础概念，这里将是重点，梳理 GMP 的调度流程。其实在 【golang源码分析】之启动追踪 中以及梳理了一下启动流程，涉及到的地方，这里会简要的过一下。初始化程序的入口12345678910// src/runtime/rt0_linux_amd64.s//  linux amd64 系统的启动函数T">
<meta name="twitter:image" content="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/GPM%E8%B0%83%E5%BA%A6.jpg">
  <link rel="canonical" href="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>【golang源码分析】之GPM调度 | Vee Zhang</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <a href="https://github.com/veezhang" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vee Zhang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一个奋斗在IT界的Coder</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-主页">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>主页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-归档">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-分类">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-标签">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-关于">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vee Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/v.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vee Zhang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">【golang源码分析】之GPM调度

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-02-02 08:54:23" itemprop="dateCreated datePublished" datetime="2020-02-02T08:54:23+00:00">2020-02-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-15 08:26:44" itemprop="dateModified" datetime="2020-05-15T08:26:44+00:00">2020-05-15</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>&emsp;&emsp;上一篇 <a href>【golang源码分析】之GPM概述</a> ，我们介绍 GPM 的一些基础概念，这里将是重点，梳理 GMP 的调度流程。其实在 <a href="https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/#more">【golang源码分析】之启动追踪</a> 中以及梳理了一下启动流程，涉及到的地方，这里会简要的过一下。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="程序的入口"><a href="#程序的入口" class="headerlink" title="程序的入口"></a>程序的入口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/rt0_linux_amd64.s</span></span><br><span class="line"><span class="comment">//  linux amd64 系统的启动函数</span></span><br><span class="line">TEXT _rt0_amd64_linux(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">    JMP _rt0_amd64(SB) <span class="comment">// 跳转到_rt0_amd64函数， 在 asm_amd64.s 中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), DI   <span class="comment">// argc     //  设置参数argc</span></span><br><span class="line">    LEAQ    <span class="number">8</span>(SP), SI   <span class="comment">// argv     //  设置参数argv</span></span><br><span class="line">    JMP runtime·rt0_go(SB)          <span class="comment">//  跳转到runtime·rt0_go</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>然后会调用 runtime·rt0_go 来初始化，是非常核心的代码。</p>
<h3 id="初始化-g0"><a href="#初始化-g0" class="headerlink" title="初始化 g0"></a>初始化 g0</h3><p>&emsp;&emsp;g0 的主要作用是提供一个栈供 runtime 代码执行，因此这里主要对 g0 的几个与栈有关的成员进行了初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create istack out of the given (operating system) stack.</span></span><br><span class="line">	<span class="comment">// _cgo_init may update stackguard.</span></span><br><span class="line">	<span class="comment">// 从给定（操作系统）栈中创建 istack 。 _cgo_init 可能更新 stackguard</span></span><br><span class="line">	<span class="comment">// runtime.g0 位于 runtime/proc.go</span></span><br><span class="line">	<span class="comment">// 初始化 g0，g0 的栈实际上就是 linux 分配的栈，大约 64k。</span></span><br><span class="line">	MOVQ	$runtime·g0(SB), DI					<span class="comment">//  DI = runtime·g0</span></span><br><span class="line">	LEAQ	(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX				<span class="comment">//  BX = SP-64*1024+104</span></span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)				<span class="comment">//  g0.stackguard0 = SP-64*1024+104</span></span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)				<span class="comment">//  g0.stackguard1 = g0.stackguard0</span></span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)			<span class="comment">//  g0.stack.lo = g0.stackguard0</span></span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)			<span class="comment">//  g0.stack.hi = SP</span></span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h3 id="主线程绑定-m0"><a href="#主线程绑定-m0" class="headerlink" title="主线程绑定 m0"></a>主线程绑定 m0</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  设置tls， Thread Local Storage</span></span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI			<span class="comment">//  DI = m0.tls ，这个会在 runtime·settls 中使用</span></span><br><span class="line">	CALL	runtime·settls(SB)					<span class="comment">// 调用 runtime·settls</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the per-goroutine and per-mach "registers"</span></span><br><span class="line">	<span class="comment">// 将 g0 放到 tls 里，这里实际上就是 m0.tls</span></span><br><span class="line">	get_tls(BX)									<span class="comment">// 等价于 MOVQ TLS, BX 。 从 TLS 起始移动 8 byte 值到 BX 寄存器，获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址</span></span><br><span class="line">	LEAQ	runtime·g0(SB), CX					<span class="comment">// CX=g0</span></span><br><span class="line">	MOVQ	CX, g(BX)							<span class="comment">// 等价于 MOVQ CX， 0(BX)(TLS*1),  也就是m0.tls[0] = g0</span></span><br><span class="line">	LEAQ	runtime·m0(SB), AX					<span class="comment">// AX=m0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">	MOVQ	CX, m_g0(AX)					<span class="comment">// m0.g0 = g0</span></span><br><span class="line">	<span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">	MOVQ	AX, g_m(CX)						<span class="comment">// g0.m = m0</span></span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码首先把 g0 的地址放入主线程的 TLS 中，然后通过 <code>m0.g0 = &amp;g0, g0.m = &amp;m0</code> 把 m0 和 g0 绑定在一起，这样，之后在主线程中通过 get_tls 可以获取到 g0 ，通过 g0 的 m 成员又可以找到 m0 ，于是这里就实现了m0和g0与主线程之间的关联。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	CALL	runtime·osinit(SB)					<span class="comment">// 初始化 os ，在 os_linux.go</span></span><br><span class="line">	CALL	runtime·schedinit(SB)				<span class="comment">// 初始化 sched ，在 proc.go</span></span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;osinit 主要是初始化 ncpu ， schedinit 是核心的初始化。</p>
<h3 id="初始化m0"><a href="#初始化m0" class="headerlink" title="初始化m0"></a>初始化m0</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	call osinit</span></span><br><span class="line"><span class="comment">//	call schedinit</span></span><br><span class="line"><span class="comment">//	make &amp; queue new G</span></span><br><span class="line"><span class="comment">//	call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br><span class="line"><span class="comment">// 启动顺序</span></span><br><span class="line"><span class="comment">// 调用 osinit</span></span><br><span class="line"><span class="comment">// 调用 schedinit</span></span><br><span class="line"><span class="comment">// make &amp; queue new G</span></span><br><span class="line"><span class="comment">// 调用 runtime·mstart</span></span><br><span class="line"><span class="comment">// 创建 G 的调用 runtime·main.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 初始化sched, 核心部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	_g_ := getg() <span class="comment">// _g_ = g0</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最大系统线程数量（即 M），参考标准库 runtime/debug.SetMaxThreads</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	mcommoninit(_g_.m) <span class="comment">// 初始化当前 M</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 网络的上次轮询时间</span></span><br><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line">	<span class="comment">// 设置procs， 根据cpu核数和环境变量GOMAXPROCS， 优先环境变量</span></span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整 P 的数量，这时所有 P 均为新建的 P，因此不能返回有本地任务的 P</span></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;g0 的地址已经被设置到了 TLS 之中，<code>_g_ := getg()</code> 获取的为 g0 ，<code>mcommoninit(_g_.m)</code> 即为初始化 m0 ，这里我们先关注下 mcommoninit 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// 通用初始化 M</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// g0 stack won't make sense for user (and is not necessary unwindable).</span></span><br><span class="line">	<span class="comment">// 检查当前 g 是否是 g0，g0 栈对用户而言是没有意义的（且不是不可避免的）</span></span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		callers(<span class="number">1</span>, mp.createstack[:])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 锁住调度器</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// 确保线程数量不会太多而溢出</span></span><br><span class="line">	<span class="keyword">if</span> sched.mnext+<span class="number">1</span> &lt; sched.mnext &#123;</span><br><span class="line">		throw(<span class="string">"runtime: thread ID overflow"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// mnext 表示当前 m 的数量，还表示下一个 m 的 id</span></span><br><span class="line">	mp.id = sched.mnext</span><br><span class="line">	<span class="comment">// 增加 m 的数量</span></span><br><span class="line">	sched.mnext++</span><br><span class="line">	<span class="comment">// 检测 m 的数量</span></span><br><span class="line">	checkmcount()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于 fastrand 快速取随机数</span></span><br><span class="line">	mp.fastrand[<span class="number">0</span>] = <span class="number">1597334677</span> * <span class="keyword">uint32</span>(mp.id)</span><br><span class="line">	mp.fastrand[<span class="number">1</span>] = <span class="keyword">uint32</span>(cputicks())</span><br><span class="line">	<span class="keyword">if</span> mp.fastrand[<span class="number">0</span>]|mp.fastrand[<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">		mp.fastrand[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 gsignal，用于处理 m 上的信号。</span></span><br><span class="line">	mpreinit(mp)</span><br><span class="line">	<span class="comment">// gsignal 的运行栈边界处理</span></span><br><span class="line">	<span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add to allm so garbage collector doesn't free g-&gt;m</span></span><br><span class="line">	<span class="comment">// when it is just in a register or thread-local storage.</span></span><br><span class="line">	<span class="comment">// 添加到 allm 中，从而当它刚保存到寄存器或本地线程存储时候 GC 不会释放 g-&gt;m</span></span><br><span class="line">	<span class="comment">// 每一次调用都会将 allm 给 alllink，给完之后自身被 mp 替换，在下一次的时候又给 alllink ，从而形成链表</span></span><br><span class="line">	mp.alllink = allm</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumCgoCall() iterates over allm w/o schedlock,</span></span><br><span class="line">	<span class="comment">// so we need to publish it safely.</span></span><br><span class="line">	<span class="comment">// NumCgoCall() 会在没有使用 schedlock 时遍历 allm，因此我们需要安全的修改。</span></span><br><span class="line">	<span class="comment">// 等价于 allm = mp</span></span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line">	<span class="comment">//  m 的通用初始化完成，解锁调度器</span></span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate memory to hold a cgo traceback if the cgo call crashes.</span></span><br><span class="line">	<span class="comment">// 分配内存来保存当 cgo 调用崩溃时候的回溯</span></span><br><span class="line">	<span class="keyword">if</span> iscgo || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">		mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;mcommoninit 并未对 m0 做什么关于调度相关的初始化，只是将 m0 放入全局链表 allm 之中。</p>
<h3 id="初始化allp"><a href="#初始化allp" class="headerlink" title="初始化allp"></a>初始化allp</h3><p>&emsp;&emsp;然后我们在关注 procresize 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class="line"><span class="comment">// gcworkbufs are not being modified by either the GC or</span></span><br><span class="line"><span class="comment">// the write barrier code.</span></span><br><span class="line"><span class="comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class="line"><span class="comment">// 修改 P 的数量，此时所有工作均被停止 STW，sched 被锁定。 gcworkbufs 既不会被 GC 修改，也不会被 write barrier 修改。</span></span><br><span class="line"><span class="comment">// 返回带有 local work 的 P 列表，他们需要被调用方调度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取之前的 P 个数</span></span><br><span class="line">	old := gomaxprocs</span><br><span class="line">	<span class="comment">// 边界检查</span></span><br><span class="line">	<span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"procresize: invalid arg"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// trace 相关</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGomaxprocs(nprocs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update statistics</span></span><br><span class="line">	<span class="comment">// 更新统计信息，记录此次修改 gomaxprocs 的时间</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	<span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">		sched.totaltime += <span class="keyword">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">	&#125;</span><br><span class="line">	sched.procresizetime = now</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Grow allp if necessary.</span></span><br><span class="line">	<span class="comment">// 必要时增加 allp</span></span><br><span class="line">	<span class="comment">// 这个时候本质上是在检查用户代码是否有调用过 runtime.MAXGOPROCS 调整 p 的数量。</span></span><br><span class="line">	<span class="comment">// 此处多一步检查是为了避免内部的锁，如果 nprocs 明显小于 allp 的可见数量，则不需要进行加锁</span></span><br><span class="line">	<span class="keyword">if</span> nprocs &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">		<span class="comment">// Synchronize with retake, which could be running</span></span><br><span class="line">		<span class="comment">// concurrently since it doesn't run on a P.</span></span><br><span class="line">		<span class="comment">// 此处与 retake 同步，它可以同时运行，因为它不会在 P 上运行。</span></span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		<span class="keyword">if</span> nprocs &lt;= <span class="keyword">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">			<span class="comment">// 如果 allp 容量足够，去切片就好了</span></span><br><span class="line">			allp = allp[:nprocs]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则 allp 容量不够，重新申请</span></span><br><span class="line">			nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">			<span class="comment">// Copy everything up to allp's cap so we</span></span><br><span class="line">			<span class="comment">// never lose old allocated Ps.</span></span><br><span class="line">			<span class="comment">// 将所有内容复制到 allp 的上，这样我们就永远不会丢失旧分配的P 。</span></span><br><span class="line">			<span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">			allp = nallp</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize new P's</span></span><br><span class="line">	<span class="comment">// 初始化新的 P</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">		pp := allp[i]</span><br><span class="line">		<span class="comment">// 如果 p 是新创建的(新创建的 p 在数组中为 nil)，则申请新的 P 对象</span></span><br><span class="line">		<span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">			pp = <span class="built_in">new</span>(p)</span><br><span class="line">			pp.id = i            <span class="comment">//  p 的 id 就是它在 allp 中的索引</span></span><br><span class="line">			pp.status = _Pgcstop <span class="comment">// 新创建的 p 处于 _Pgcstop 状态</span></span><br><span class="line">			pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">				pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			pp.wbBuf.reset()</span><br><span class="line">			atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 为 P 分配 cache 对象</span></span><br><span class="line">		<span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果 old == 0 且 i == 0 说明这是引导阶段初始化第一个 p 。schedinit 中 mallocinit 有初始化一个 mcache</span></span><br><span class="line">			<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 确认当前 g 的 m 的 mcache 非空</span></span><br><span class="line">				<span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">					throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				pp.mcache = getg().m.mcache <span class="comment">// bootstrap</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pp.mcache = allocmcache()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果 启动了 race 并且 racectx 为 0，则新建</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &amp;&amp; pp.racectx == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 如果 old == 0 且 i == 0 说明这是引导阶段初始化第一个 p 。 schedinit 中有初始化一个 raceproccreate</span></span><br><span class="line">			<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">				pp.racectx = raceprocctx0</span><br><span class="line">				raceprocctx0 = <span class="number">0</span> <span class="comment">// bootstrap</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pp.racectx = raceproccreate()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free unused P's</span></span><br><span class="line">	<span class="comment">// 释放不用的 P</span></span><br><span class="line">	<span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &amp;&amp; p == getg().m.p.ptr() &#123;</span><br><span class="line">			<span class="comment">// moving to p[0], pretend that we were descheduled</span></span><br><span class="line">			<span class="comment">// and then scheduled again to keep the trace sane.</span></span><br><span class="line">			<span class="comment">// 移至 p[0] ，假装我们已被调度，然后再次调度以保持跟踪正常。</span></span><br><span class="line">			traceGoSched()</span><br><span class="line">			traceProcStop(p)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// move all runnable goroutines to the global queue</span></span><br><span class="line">		<span class="comment">// 将所有的 runnable goroutines 移动到全局队列 sched.runq</span></span><br><span class="line">		<span class="keyword">for</span> p.runqhead != p.runqtail &#123;</span><br><span class="line">			<span class="comment">// pop from tail of local queue</span></span><br><span class="line">			<span class="comment">// 从本地队列的尾部 pop</span></span><br><span class="line">			p.runqtail--</span><br><span class="line">			gp := p.runq[p.runqtail%<span class="keyword">uint32</span>(<span class="built_in">len</span>(p.runq))].ptr()</span><br><span class="line">			<span class="comment">// push onto head of global queue</span></span><br><span class="line">			<span class="comment">//  push 到全局队列的头部</span></span><br><span class="line">			globrunqputhead(gp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果 runnext 不为 0，也加入到全局队列 sched.runq</span></span><br><span class="line">		<span class="keyword">if</span> p.runnext != <span class="number">0</span> &#123;</span><br><span class="line">			globrunqputhead(p.runnext.ptr())</span><br><span class="line">			p.runnext = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if there's a background worker, make it runnable and put</span></span><br><span class="line">		<span class="comment">// it on the global queue so it can clean itself up</span></span><br><span class="line">		<span class="comment">// 如果存在 gc 后台 worker，则让其 runnable 并将其放到全局队列中从而可以让其对自身进行清理</span></span><br><span class="line">		<span class="keyword">if</span> gp := p.gcBgMarkWorker.ptr(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			globrunqput(gp)</span><br><span class="line">			<span class="comment">// This assignment doesn't race because the</span></span><br><span class="line">			<span class="comment">// world is stopped.</span></span><br><span class="line">			<span class="comment">// 此赋值不会发生竞争，因为此时已经 STW</span></span><br><span class="line">			p.gcBgMarkWorker.set(<span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Flush p's write barrier buffer.</span></span><br><span class="line">		<span class="comment">// 刷新 p 的写屏障缓存</span></span><br><span class="line">		<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">			wbBufFlush1(p)</span><br><span class="line">			p.gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置 sudogbuf</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> p.sudogbuf &#123;</span><br><span class="line">			p.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.sudogcache = p.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> p.deferpool &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> p.deferpoolbuf[i] &#123;</span><br><span class="line">				p.deferpoolbuf[i][j] = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.deferpool[i] = p.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 释放当前 P 绑定的 mcache</span></span><br><span class="line">		freemcache(p.mcache)</span><br><span class="line">		p.mcache = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// 将当前 P 的 G 复链转移到全局</span></span><br><span class="line">		gfpurge(p)</span><br><span class="line">		traceProcFree(p)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceprocdestroy(p.racectx)</span><br><span class="line">			p.racectx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.gcAssistTime = <span class="number">0</span></span><br><span class="line">		p.status = _Pdead</span><br><span class="line">		<span class="comment">// can't free P itself because it can be referenced by an M in syscall</span></span><br><span class="line">		<span class="comment">// 不能释放 P 本身，因为它可能被系统调用的 M 引用。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trim allp.</span></span><br><span class="line">	<span class="comment">// 修剪 allp</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		allp = allp[:nprocs]</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123; <span class="comment">// 当前的 P 不需要被释放</span></span><br><span class="line">		<span class="comment">// continue to use the current P</span></span><br><span class="line">		<span class="comment">// 继续使用当前 P</span></span><br><span class="line">		_g_.m.p.ptr().status = _Prunning</span><br><span class="line">		_g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// release the current P and acquire allp[0]</span></span><br><span class="line">		<span class="comment">// 释放当前 P，然后获取 allp[0]</span></span><br><span class="line">		<span class="comment">//  p 和 m 解绑</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			_g_.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		_g_.m.p = <span class="number">0</span></span><br><span class="line">		_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// 更换到 allp[0]</span></span><br><span class="line">		p := allp[<span class="number">0</span>]</span><br><span class="line">		p.m = <span class="number">0</span></span><br><span class="line">		p.status = _Pidle</span><br><span class="line">		acquirep(p) <span class="comment">// 直接将 allp[0] 绑定到当前的 M</span></span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoStart()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> runnablePs *p</span><br><span class="line">	<span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		<span class="comment">// 确保不是当前正在使用的 P</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将 p 设为 _Pidle</span></span><br><span class="line">		p.status = _Pidle</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 本地任务列表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line">			<span class="comment">// 放入 idle 链表</span></span><br><span class="line">			pidleput(p)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果有本地任务，则为其绑定一个 M（不一定能获取到）</span></span><br><span class="line">			p.m.set(mget())</span><br><span class="line">			<span class="comment">// 第一个循环为 nil，后续则为上一个 p，此处即为构建可运行的 p 链表</span></span><br><span class="line">			p.link.set(runnablePs)</span><br><span class="line">			runnablePs = p</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stealOrder.reset(<span class="keyword">uint32</span>(nprocs))</span><br><span class="line">	<span class="keyword">var</span> int32p *<span class="keyword">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32 // 让编译器检查 gomaxprocs 是 int32 类型</span></span><br><span class="line">	atomic.Store((*<span class="keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="keyword">uint32</span>(nprocs))</span><br><span class="line">	<span class="comment">// 让编译器检查 gomaxprocs 是 int32 类型</span></span><br><span class="line">	<span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate p and the current m.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is allowed to have write barriers even if the caller</span></span><br><span class="line"><span class="comment">// isn't because it immediately acquires _p_.</span></span><br><span class="line"><span class="comment">// 将 p 关联到当前的 m 。因为该函数会立即 acquire P，因此即使调用方不允许 write barrier，此函数仍然允许 write barrier。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Do the part that isn't allowed to have write barriers.</span></span><br><span class="line">	<span class="comment">// 此处不允许 write barrier 。关联了当前的 M 到 P 上。</span></span><br><span class="line">	wirep(_p_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Have p; write barriers now allowed. // 已经获取了 p，因此之后允许 write barrier</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Perform deferred mcache flush before this P can allocate</span></span><br><span class="line">	<span class="comment">// from a potentially stale mcache.</span></span><br><span class="line">	<span class="comment">// 在此 P 可以从可能过时的 mcache 分配前执行延迟的 mcache flush</span></span><br><span class="line">	_p_.mcache.prepareForSweep()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceProcStart()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wirep is the first step of acquirep, which actually associates the</span></span><br><span class="line"><span class="comment">// current M to _p_. This is broken out so we can disallow write</span></span><br><span class="line"><span class="comment">// barriers for this part, since we don't yet have a P.</span></span><br><span class="line"><span class="comment">//  wirep 为 acquirep 的实际获取 p 的第一步，它关联了当前的 M 到 P 上。 我们在这部分使用 write barriers 被打破了，因为我们还没有P。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前的 m 已经关联了 p</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> || _g_.m.mcache != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"wirep: already in go"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 _p_ 已经关联了 m ， 且 _p_ 的状态不是 _Pidle</span></span><br><span class="line">	<span class="keyword">if</span> _p_.m != <span class="number">0</span> || _p_.status != _Pidle &#123;</span><br><span class="line">		id := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> _p_.m != <span class="number">0</span> &#123;</span><br><span class="line">			id = _p_.m.ptr().id</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"wirep: p-&gt;m="</span>, _p_.m, <span class="string">"("</span>, id, <span class="string">") p-&gt;status="</span>, _p_.status, <span class="string">"\n"</span>)</span><br><span class="line">		throw(<span class="string">"wirep: invalid p state"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关联当前 m 和 _p_ ， 并设置 _p_ 为 _Prunning</span></span><br><span class="line">	_g_.m.mcache = _p_.mcache <span class="comment">// 使用 p 的 mcache</span></span><br><span class="line">	_g_.m.p.set(_p_)          <span class="comment">// 将 p 关联到到 m</span></span><br><span class="line">	_p_.m.set(_g_.m)          <span class="comment">// 将 m 关联到到 p</span></span><br><span class="line">	_p_.status = _Prunning    <span class="comment">// 设置 _Prunning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个函数看起来比较长，其实并不复杂，主要流程是：</p>
<ol>
<li>初始化全局变量 allp ， <code>allp = make([]*p, nprocs)</code> ，可能存在复用和扩增之前的 allp ，由于这里是第一次初始化，所以仅仅是初始化。</li>
<li>初始化所有新的 P ， 包括 status(-&gt;<code>_Pgcstop</code>) ， sudogbuf , mcache 等。</li>
<li>释放不用的 P ，包括本地运行队列， sudogbuf ， mcache ， status(-&gt;<code>_Pdead</code>) 等。</li>
<li>如果有当前的 P 并且这个 P 不是被释放的，则设置状态改为 <code>_Prunning</code> ；否则设置为 <code>_Pidle</code> ， 然后调用 acquirep -&gt;wirep 又会将其状态设置为 <code>_Prunning</code> ，并且设置其 mcache 。由于这里还没初始化 m0-&gt;p ，所以会走后面的逻辑，此时 m0 和 allp[0] 绑定。</li>
<li>把其它的 P 设置为 <code>_Pidle</code> 状态并根据情况放置到 pidle 空闲队列之中，或者返回可运行的 P 。这里肯定是将其它所有的设置为 <code>_Pidle</code> 状态。</li>
</ol>
<p>&emsp;&emsp;至此，m0, g0 和 allp 都初始化完成了，那么怎么启动我们的 main 函数呢？ schedinit 中貌似并没有相关的代码。我们返回来看 runtime·rt0_go 后面做了什么事情。</p>
<h3 id="创建main-goroutine"><a href="#创建main-goroutine" class="headerlink" title="创建main goroutine"></a>创建main goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a new goroutine to start program</span></span><br><span class="line">	<span class="comment">// 创建 goroutine 并加入到等待队列，该 goroutine 执行 runtime.mainPC 所指向的函数</span></span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		<span class="comment">// entry//  入口函数 在 proc.go 中</span></span><br><span class="line">	PUSHQ	AX									<span class="comment">// 压栈，设置参数 runtime·newproc 的 fn</span></span><br><span class="line">	PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size				// 压栈，设置参数 runtime·newproc 的 siz</span></span><br><span class="line">	CALL	runtime·newproc(SB)					<span class="comment">// 调用 runtime·newproc ，在 proc.go 函数原型： func newproc(siz int32, fn *funcval)</span></span><br><span class="line">	POPQ	AX									<span class="comment">// 弹出 PUSHQ	$0</span></span><br><span class="line">	POPQ	AX									<span class="comment">// 弹出 PUSHQ	AX</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的变量 mainPC 为 runtime.main 函数的地址，该变量为 read only</span></span><br><span class="line">DATA	runtime·mainPC+<span class="number">0</span>(SB)/<span class="number">8</span>,$runtime·main(SB)</span><br><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面我们可以看到，设置 runtime·mainPC 函数，然后调用 runtime·newproc 来创建 g ，注意此处的 runtime·mainPC 还不是我们写代码的 main 函数，而是 runtime 中定义的 main 函数，后面会讲到，这里首先看 newproc 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">// 创建 G 运行 fn , 参数大小为 siz 。把 G 放到等待队列。编译器会将 go 语句转化为该调用。</span></span><br><span class="line"><span class="comment">// 这时不能将栈进行分段，因为它假设了参数在 &amp;fn 之后顺序有效；如果 stack 进行了分段则他们不无法被拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	<span class="comment">//  add 是一个指针运算，跳过函数指针，把栈上的参数起始地址找到，见 runtime2.go 中的 funcval 类型</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="comment">// 获取调用方 PC 寄存器值</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	<span class="comment">// 用 g0 系统栈创建 goroutine 对象。传递的参数包括 fn 函数入口地址, argp 参数起始地址, siz 参数长度, gp(g0)，调用方 pc(goroutine)</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个运行 fn 的新 g，具有 narg 字节大小的参数，从 argp 开始。callerps 是 go 语句的起始地址。新创建的 g 会被放入 g 的队列中等待运行。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 因为是在系统栈运行所以此时的 g 为 g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 p</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="comment">// 从 g 空闲列表中，根据 p 获得一个新的 g</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化阶段，gfget 是不可能找到 g 的，也可能运行中本来就已经耗尽了</span></span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 创建一个拥有 _StackMin (2kb) 大小的栈的 g</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		<span class="comment">// 将新创建的 g 从 _Gidle 更新为 _Gdead 状态</span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		<span class="comment">// 将 Gdead 状态的 g 添加到 allg，这样 GC 不会扫描未初始化的栈</span></span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算运行空间大小，与 spAlign 对齐</span></span><br><span class="line">	totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">	<span class="comment">// 确定 sp 和参数入栈位置</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理参数，当有参数时，将参数拷贝到 goroutine 的执行栈中</span></span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 从 argp 参数开始的位置，复制 narg 个字节到 spArg（参数拷贝）</span></span><br><span class="line">		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理、创建并初始化的 g 的运行现场</span></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	<span class="comment">// 设置 newg 的 sched 成员，调度器需要依靠这些字段才能把 goroutine 调度到 CPU 上运行。</span></span><br><span class="line">	newg.sched.sp = sp <span class="comment">// newg 的栈顶</span></span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	<span class="comment">// newg.sched.pc 表示当 newg 被调度起来运行时从这个地址开始执行指令，也说是 goexit 函数的第二条指令。</span></span><br><span class="line">	<span class="comment">// 把 pc 设置成了 goexit 这个函数偏移 1 （ amd64 中 sys.PCQuantum 等于 1 ）的位置。</span></span><br><span class="line">	<span class="comment">// 这里为什么 goexit 是第二条指令？ 需要看 gostartcallfn 函数。</span></span><br><span class="line">	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function // +PCQuantum 从而前一个指令还在相同的函数内</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">	<span class="comment">// gostartcallfn 会获取 fn 的函数地址，然后调用 gostartcall</span></span><br><span class="line">	<span class="comment">// gostartcall函数的主要作用有两个：</span></span><br><span class="line">	<span class="comment">// 调整 newg 的栈空间，把 goexit 函数的第二条指令的地址入栈，伪造成 goexit 函数调用了 fn ，从而使 fn 执行完成后执行 ret 指令时返回到 goexit 继续执行完成最后的清理工作；</span></span><br><span class="line">	<span class="comment">// 重新设置 newg.buf.pc 为需要执行的函数的地址，即 fn ，初始化时为 runtime.main 函数的地址。</span></span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 g 的基本状态</span></span><br><span class="line">	newg.gopc = callerpc                     <span class="comment">//主要用于 traceback</span></span><br><span class="line">	newg.ancestors = saveAncestors(callergp) <span class="comment">// 调试相关，追踪调用方</span></span><br><span class="line">	<span class="comment">// 设置 newg 的 startpc 为 fn.fn ，该成员主要用于函数调用栈的 traceback 和栈收缩</span></span><br><span class="line">	<span class="comment">// newg 真正从哪里开始执行并不依赖于这个成员，而是 newg.sched.pc</span></span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 g 更换为 _Grunnable 状态</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将这里新创建的 g 放入 p 的本地队列，如果已满，则放入全局队列，true 表示放入执行队列的下一个 (_p_.runnext)，false 表示放入队尾</span></span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/stack.go</span></span><br><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="comment">// 调整 Gobuf ，就好像它执行了对 fn 的调用了一样，然后立即进行 gosave 。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn = unsafe.Pointer(fv.fn) <span class="comment">// fn: gorotine 的入口地址，初始化时对应的是 runtime.main ，其它对应各自的 gorotine 的入口地址。</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">	&#125;</span><br><span class="line">	gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/sys_x86.go</span></span><br><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.、</span></span><br><span class="line"><span class="comment">// 调整 Gobuf ，就好像它使用上下文 ctxt 执行了对 fn 的调用，然后立即执行了 gosave 一样。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// newg 的栈顶，目前 newg 栈上只有 fn 函数的参数， sp 指向的是 fn 的第一参数</span></span><br><span class="line">	sp := buf.sp</span><br><span class="line">	<span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">		sp -= sys.PtrSize</span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	sp -= sys.PtrSize <span class="comment">// 栈空间是高地址向低地址增长，为返回地址预留空间</span></span><br><span class="line">	<span class="comment">// 这里在伪装 fn 是被 goexit 函数调用的，使得 fn 执行完后返回到 goexit 继续执行，从而完成清理工作</span></span><br><span class="line">	*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc <span class="comment">// 在栈上放入 goexit+1 的地址</span></span><br><span class="line">	buf.sp = sp                              <span class="comment">// 新设置 newg 的栈顶寄存器</span></span><br><span class="line">	<span class="comment">// 这里才真正让 newg 的 pc 寄存器指向 fn 函数，等到 newg 被调度起来运行时，调度器会把 buf.pc 放入 cpu 的 IP 寄存器，</span></span><br><span class="line">	<span class="comment">// 从而使 newg 得以在 cpu 上真正的运行起来。</span></span><br><span class="line">	buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">	buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面我们可以看到， newproc 最终在 g0 上调用 newproc1 ，然后 <code>newg := gfget(_p_)</code> 获取一个 g ，如果获取不到则通过 malg （malg会设置其栈字段）新建一个 g （这个当然是新建），为其分配 2KB 大小的栈，设置其状态为 <code>_Gdead</code> 然后添加到全局变量 allgs 中。</p>
<p>&emsp;&emsp;接着会拷贝参数到 newg 的栈上，然后初始化 newg.sched ，其中最重要的莫过于 sp , pc 。注意 newg.sched.pc 先设置的是 goexit + 1 （也说是 goexit 函数的第二条指令。），然后调用了 gostartcallfn , gostartcallfn 会获取 fn 的函数地址，然后调用 gostartcall 。</p>
<p>&emsp;&emsp;gostartcall函数的主要作用有两个：</p>
<ol>
<li>调整 newg 的栈空间，把 goexit 函数的第二条指令的地址入栈，伪造成 goexit 函数调用了 fn ，从而使 fn 执行完成后执行 ret 指令时返回到 goexit 继续执行完成最后的清理工作；</li>
<li>重新设置 newg.buf.pc 为需要执行的函数的地址，即 fn ，初始化时为 runtime.main 函数的地址。</li>
</ol>
<p>&emsp;&emsp;然后设置 newg 的一些基本信息，设置为 <code>_Grunnable</code> 状态，然后设置为下一个待运行的。因为初始化的时候队列为空，不可能放到全局队列，p.runnext 也还没有，这里就设置到 p.runnext ，就等待调度了，用户确定不了什么时候开始执行。</p>
<h3 id="开始调度循环"><a href="#开始调度循环" class="headerlink" title="开始调度循环"></a>开始调度循环</h3><p>&emsp;&emsp;前面创建了一个 goroutine，设置好了 sched 成员的 sp 和 pc 字段，并且将其添加到了 p0 的本地可运行队列，还没有绑定 m ，坐等调度器的调度。我们继续看 runtime·rt0_go 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start this M</span></span><br><span class="line">	CALL	runtime·mstart(SB)					<span class="comment">// 启动调度程序，调度到刚刚创建的 goroutine 执行，在 proc.go 函数原型： func mstart()</span></span><br><span class="line"></span><br><span class="line">	CALL	runtime·abort(SB)					<span class="comment">// mstart should never return //  mstart 永远不会返回</span></span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的变量 mainPC 为 runtime.main 函数的地址，该变量为 read only</span></span><br><span class="line">DATA	runtime·mainPC+<span class="number">0</span>(SB)/<span class="number">8</span>,$runtime·main(SB)</span><br><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面终于调用到 runtime·mstart 核心代码了，开启调度器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// Called to start an M.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must not split the stack because we may not even have stack</span></span><br><span class="line"><span class="comment">// bounds set up yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run during STW (because it doesn't have a P yet), so write</span></span><br><span class="line"><span class="comment">// barriers are not allowed.</span></span><br><span class="line"><span class="comment">// 启动 M ， M 的入口函数</span></span><br><span class="line"><span class="comment">// 该函数不允许分段栈，因为我们甚至还没有设置栈的边界。它可能会在 STW 阶段运行（因为它还没有 P），所以 write barrier 也是不允许的</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确定执行栈的边界。通过检查 g 执行占的边界来确定是否为系统栈</span></span><br><span class="line">	osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> osStack &#123;</span><br><span class="line">		<span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line">		<span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line">		<span class="comment">// minit may update the stack bounds.</span></span><br><span class="line">		<span class="comment">// 根据系统栈初始化执行栈的边界。cgo 可能会离开 stack.hi 。minit 可能会更新栈的边界</span></span><br><span class="line">		size := _g_.stack.hi</span><br><span class="line">		<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">			size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.stack.hi = <span class="keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Initialize stack guards so that we can start calling</span></span><br><span class="line">	<span class="comment">// both Go and C functions with stack growth prologues.</span></span><br><span class="line">	<span class="comment">// 初始化堆栈守卫，以便我们可以使用堆栈增长 prologue (序言) 开始调用Go和C函数。</span></span><br><span class="line">	_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">	_g_.stackguard1 = _g_.stackguard0</span><br><span class="line">	<span class="comment">// 启动 M</span></span><br><span class="line">	mstart1()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Exit this thread.</span></span><br><span class="line">	<span class="comment">// 退出线程</span></span><br><span class="line">	<span class="keyword">if</span> GOOS == <span class="string">"windows"</span> || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"plan9"</span> || GOOS == <span class="string">"darwin"</span> || GOOS == <span class="string">"aix"</span> &#123;</span><br><span class="line">		<span class="comment">// Window, Solaris, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line">		<span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line">		<span class="comment">// so the logic above hasn't set osStack yet.</span></span><br><span class="line">		<span class="comment">// Window，Solaris，Darwin，AIX和Plan 9始终对栈进行系统分配，但将其放在mstart之前的_g_.stack中，因此上述逻辑尚未设置osStack。</span></span><br><span class="line">		osStack = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 退出线程</span></span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;mstart 主要获取当前的 g ，然后设置 stackguard0 ， stackguard1 ，然后直接调用 mstart1 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前执行的 g 是不是 g0</span></span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">"bad runtime·mstart"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record the caller for use as the top of stack in mcall and</span></span><br><span class="line">	<span class="comment">// for terminating the thread.</span></span><br><span class="line">	<span class="comment">// We're never coming back to mstart1 after we call schedule,</span></span><br><span class="line">	<span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line">	<span class="comment">// 这里会记录前一个调用者的状态， 包含 PC , SP 以及其他信息。这份记录会当作最初栈 (top stack)，给之后的 mcall 调用，也用来结束那个线程。</span></span><br><span class="line">	<span class="comment">// 接下來在 mstart1 调用到 schedule 之后就再也不会回到这个地方了，所以其他调用可以重用当前帧。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 借助编译器的帮助获取 PC 和 SP , 然后在 save 中更新当前 G 的 sched (type gobuf) 的一些成员， 保存调用者的 pc 和 sp ，让日后其他执行者执行 gogo 函数的时候使用。</span></span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	asminit() <span class="comment">// 初始化汇编，但是 amd64 架构下不需要执行任何代码就立刻返回，其他像是 arm、386 才有一些需在这里设定一些 CPU 相关的內容。</span></span><br><span class="line">	minit()   <span class="comment">// 初始化m 包括信号栈和信号掩码，procid</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line">	<span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line">	<span class="comment">// 设置信号 handler ；在 minit 之后，因为 minit 可以准备处理信号的的线程</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">		<span class="comment">// 在当前的 goroutine 的所属执行者是 m0 的情況下进入 mstartm0 函数，正式启动在此之前的 signal 处理设定，其中最关键的是 initsig 函数。</span></span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行启动函数</span></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前 m 并非 m0，则要求绑定 p</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 彻底准备好，开始调度，永不返回</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mstartm0 implements part of mstart1 that only runs on the m0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed here because we know the GC can't be</span></span><br><span class="line"><span class="comment">// running yet, so they'll be no-ops.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mstartm0 实现了一部分 mstart1，只运行在 m0 上。允许 write barrier，因为我们知道 GC 此时还不能运行，因此他们没有操作。</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstartm0</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create an extra M for callbacks on threads not created by Go.</span></span><br><span class="line">	<span class="comment">// An extra M is also needed on Windows for callbacks created by</span></span><br><span class="line">	<span class="comment">// syscall.NewCallback. See issue #6751 for details.</span></span><br><span class="line">	<span class="comment">// 创建一个额外的 M 处理 non-Go 线程（cgo 调用中产生的线程）的回调，并且只创建一个。windows 上也需要额外 M 来处理 syscall.NewCallback 产生的回调，见 issue #6751</span></span><br><span class="line">	<span class="keyword">if</span> (iscgo || GOOS == <span class="string">"windows"</span>) &amp;&amp; !cgoHasExtraM &#123;</span><br><span class="line">		cgoHasExtraM = <span class="literal">true</span></span><br><span class="line">		newextram()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化信号。</span></span><br><span class="line">	initsig(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save updates getg().sched to refer to pc and sp so that a following</span></span><br><span class="line"><span class="comment">// gogo will restore pc and sp.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// save must not have write barriers because invoking a write barrier</span></span><br><span class="line"><span class="comment">// can clobber getg().sched.</span></span><br><span class="line"><span class="comment">// save 更新了 getg().sched 的 pc 和 sp 的指向，并允许 gogo 能够恢复到 pc 和 sp 。 save 不允许 write barrier， 因为会破坏 getg().sched 。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(pc, sp <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	_g_.sched.pc = pc</span><br><span class="line">	_g_.sched.sp = sp</span><br><span class="line">	_g_.sched.lr = <span class="number">0</span></span><br><span class="line">	_g_.sched.ret = <span class="number">0</span></span><br><span class="line">	_g_.sched.g = guintptr(unsafe.Pointer(_g_))</span><br><span class="line">	<span class="comment">// We need to ensure ctxt is zero, but can't have a write</span></span><br><span class="line">	<span class="comment">// barrier here. However, it should always already be zero.</span></span><br><span class="line">	<span class="comment">// Assert that.</span></span><br><span class="line">	<span class="comment">// 我们必须确保 ctxt 为零，但这里不允许 write barrier。 所以这里只是做一个断言。</span></span><br><span class="line">	<span class="keyword">if</span> _g_.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">		badctxt()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先调用 save 函数来保存 g0 的调度信息。save 函数执行完成后，继续其它跟 m 相关的一些初始化，然后调用调度系统的核心函数 schedule() 完成 goroutine 的调度，每次调度 goroutine 都是从 schedule 函数开始的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">// 调度器的一轮：找到 runnable goroutine 并进行执行且永不返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调度的时候， m 不能持有 locks</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前 M 锁定了某个 G ，那么应该交出P，进入休眠。等待某个 M 调度拿到 lockedg ，然后唤醒 lockedg 的 M</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()                       <span class="comment">// 停止当前正在执行锁住的 g 的 m 的执行，直到 g 重新变为 runnable ， 被唤醒 。 返回时关联了 P</span></span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line">	<span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line">	<span class="comment">// 我们不应该调度一个正在执行 cgo 调用的 g ， 因为 cgo 在使用当前 m 的 g0 栈</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">		throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="comment">// 如果当前 GC 需要（STW), 则调用 gcstopm 休眠当前的 M</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果有安全点函数， 则执行</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 如果启动 trace 或等待 trace reader</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">		<span class="comment">// 有 trace reader 需要被唤醒则标记 _Grunnable</span></span><br><span class="line">		gp = traceReader()</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  如果当前 GC 正在标记阶段，允许置黑对象，则查找有没有待运行的 GC Worker, GC Worker 也是一个 G</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 说明不在 gc</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">		<span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">		<span class="comment">// by constantly respawning each other.</span></span><br><span class="line">		<span class="comment">// 每调度 61 次，就检查一次全局队列，保证公平性。否则两个 goroutine 可以通过不断地互相 respawn（重生） 一直占领本地的 runqueue</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 从p的本地队列中获取</span></span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">		<span class="comment">// 本地有 g ，则 m 不应该在 spinning 状态</span></span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 想尽办法找到可运行的 G ，找不到就不用返回了</span></span><br><span class="line">		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个时候肯定取到 g 了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line">	<span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line">	<span class="comment">// start a new spinning M.</span></span><br><span class="line">	<span class="comment">// 该线程将运行 goroutine ，并且不再 spinning ，因此，如果将其标记为 spinning ，则需要立即将其重置并可能启动新的 spinning M 。</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		<span class="comment">// 如果 m 是 spinning 状态，则：</span></span><br><span class="line">		<span class="comment">//  1. 从 spinning -&gt; non-spinning</span></span><br><span class="line">		<span class="comment">//  2. 在没有 spinning 的 m 的情况下，再多创建一个新的 spinning m</span></span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果禁用用户地 G 调度，并且 gp 不能够调度， 表示 gp 是用户 G ，不是系统 G</span></span><br><span class="line">	<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">		<span class="comment">// Scheduling of this goroutine is disabled. Put it on</span></span><br><span class="line">		<span class="comment">// the list of pending runnable goroutines for when we</span></span><br><span class="line">		<span class="comment">// re-enable user scheduling and look again.</span></span><br><span class="line">		<span class="comment">// 禁用此 goroutine 的调度。 当我们重新启用用户调度并再次查看时，将其放在待处理的可运行 goroutine 列表中。</span></span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="comment">// 锁住后重新检测</span></span><br><span class="line">		<span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">			<span class="comment">// Something re-enabled scheduling while we</span></span><br><span class="line">			<span class="comment">// were acquiring the lock.</span></span><br><span class="line">			<span class="comment">// 当我们之前正在获取锁的时候，可能有什么重新启动了调度， 也就是锁住之前，可能哪里重新启动了用户 g 调度。</span></span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 加入到禁用掉的等待的可运行的 G 队尾</span></span><br><span class="line">			sched.disable.runnable.pushBack(gp)</span><br><span class="line">			sched.disable.n++</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 gp 锁定了 m</span></span><br><span class="line">	<span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line">		<span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line">		<span class="comment">//  让出 gp 给其锁定的 m ，然后阻塞等待新的 p</span></span><br><span class="line">		startlockedm(gp) <span class="comment">// 调度锁定的 m 来运行锁定的 gp</span></span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始执行</span></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P's, get g from global queue, poll network.</span></span><br><span class="line"><span class="comment">// 寻找一个可运行的 goroutine 来执行。尝试从其他的 P 偷取、从本地或者全局队列中获取、pollnet 。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">	<span class="comment">// an M.</span></span><br><span class="line">	<span class="comment">// 这里的条件与 handoffp 中的条件必须一致：如果 findrunnable 将返回 G 来运行，handoffp 必须启动 M 。</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm() <span class="comment">// 如果在 gc，则 park 当前 m，直到被 unpark 后回到 top</span></span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn() <span class="comment">// 如果需要执行安全点函数，则执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		<span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  cgo 调用被终止，继续进入</span></span><br><span class="line">	<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// local runq</span></span><br><span class="line">	<span class="comment">// 取本地队列 local runq，如果已经拿到，立刻返回</span></span><br><span class="line">	<span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gp, inheritTime</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// global runq</span></span><br><span class="line">	<span class="comment">// 全局队列 global runq，如果已经拿到，立刻返回</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Poll network.</span></span><br><span class="line">	<span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line">	<span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line">	<span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line">	<span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line">	<span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line">	<span class="comment">// anyway.</span></span><br><span class="line">	<span class="comment">// Poll 网络，优先级比从其他 P 中偷要高。在我们尝试去其他 P 偷之前，这个 netpoll 只是一个优化。如果没有 waiter 或 netpoll 中的线程已被阻塞，</span></span><br><span class="line">	<span class="comment">// 则可以安全地跳过它。如果有任何类型的逻辑竞争与被阻塞的线程（例如它已经从 netpoll 返回，但尚未设置 lastpoll），该线程无论如何都将阻塞 netpoll 。</span></span><br><span class="line">	<span class="comment">//  netpoll 已经初始化了，并且没有在等待 netpoll 的 g ，并且 sched.lastpoll != 0 ， 下面候可能将 sched.lastpoll 设置为 0 ，然后阻塞调用</span></span><br><span class="line">	<span class="comment">//  netpoll(true)，返回后才设置 lastpoll ， 如果 sched.lastpoll == 0 的话，则表示 netpoll 还在阻塞， 这时候是 netpool 没有就绪 g 的。</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 轮询就绪的网络链接，查找 runnable G</span></span><br><span class="line">		<span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">			gp := list.pop()                      <span class="comment">// 获取一个</span></span><br><span class="line">			injectglist(&amp;list)                    <span class="comment">// 将 netpool 中剩余的 runnable g 列表插入到调度器中</span></span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable) <span class="comment">// 设置状态为 _Grunnable</span></span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 返回从 netpoll 中窃取到的 g</span></span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Steal work from other P's.</span></span><br><span class="line">	<span class="comment">// 从其他 P 中窃取 work</span></span><br><span class="line">	procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class="line">		<span class="comment">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class="line">		<span class="comment">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class="line">		<span class="comment">//  GOMAXPROCS=1 或除我们之外的每个 P 都空闲。 通过返回 syscall/cgocall，network 或 timers，可以找到新 P。</span></span><br><span class="line">		<span class="comment">// 两者都不会提交到本地运行队列，因此在窃取方面毫无意义。</span></span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class="line">	<span class="comment">// This is necessary to prevent excessive CPU consumption</span></span><br><span class="line">	<span class="comment">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line">	<span class="comment">//  如果 spinning 状态下 m 的数量 &gt;= busy 状态下 p 的数量，直接进入阻塞。该步骤是有必要的，它用于当 GOMAXPROCS&gt;&gt;1 时</span></span><br><span class="line">	<span class="comment">// 但程序的并行机制很慢时昂贵的 CPU 消耗。</span></span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 m 是 non-spinning 状态，切换为 spinning</span></span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">		atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 随机窃取</span></span><br><span class="line">		<span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> top <span class="comment">// 已经进入了 GC? 回到 top ，park 当前的 m</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果偷了3次都偷不到，连 p.runnext (是当前G准备好的可运行G) 都窃取</span></span><br><span class="line">			stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">			<span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 窃取到了就返回</span></span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We have nothing to do. If we're in the GC mark phase, can</span></span><br><span class="line">	<span class="comment">// safely scan and blacken objects, and have work to do, run</span></span><br><span class="line">	<span class="comment">// idle-time marking rather than give up the P.</span></span><br><span class="line">	<span class="comment">// 没有任何 work 可做。如果我们在 GC mark 阶段，则可以安全的扫描并 blacken 对象，然后便有 work 可做，运行 idle-time 标记而非直接放弃当前的 P。</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">		gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wasm only:</span></span><br><span class="line">	<span class="comment">// If a callback returned and no other goroutine is awake,</span></span><br><span class="line">	<span class="comment">// then pause execution until a callback was triggered.</span></span><br><span class="line">	<span class="comment">// 仅限于 wasm 。如果一个回调返回后没有其他 goroutine 是苏醒的。则暂停执行直到回调被触发。</span></span><br><span class="line">	<span class="keyword">if</span> beforeIdle() &#123;</span><br><span class="line">		<span class="comment">// At least one goroutine got woken.</span></span><br><span class="line">		<span class="comment">// 至少一个 goroutine 被唤醒</span></span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span><br><span class="line">	<span class="comment">// which can change underfoot once we no longer block</span></span><br><span class="line">	<span class="comment">// safe-points. We don't need to snapshot the contents because</span></span><br><span class="line">	<span class="comment">// everything up to cap(allp) is immutable.</span></span><br><span class="line">	<span class="comment">// 放弃当前的 P 之前，对 allp 做一个快照。一旦我们不再阻塞在 safe-point 时候，可以立刻在下面进行修改。</span></span><br><span class="line">	<span class="comment">// 我们不需要对内容进行快照，因为 cap(allp) 的所有内容都是不可变的。</span></span><br><span class="line">	allpSnapshot := allp</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return P and block</span></span><br><span class="line">	<span class="comment">// 准备归还 p，对调度器加锁</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// GC 或 运行安全点函数，则回到 top</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 全局队列中又发现了 g</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取消关联 p 和当前 m</span></span><br><span class="line">	<span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">		throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 p 放入 idle 链表</span></span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	<span class="comment">// 完成归还，解锁</span></span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span><br><span class="line">	<span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span><br><span class="line">	<span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span><br><span class="line">	<span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span><br><span class="line">	<span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span><br><span class="line">	<span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span><br><span class="line">	<span class="comment">// to run the goroutine.</span></span><br><span class="line">	<span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span><br><span class="line">	<span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span><br><span class="line">	<span class="comment">// than one starving goroutine). However, if after discovering new work</span></span><br><span class="line">	<span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span><br><span class="line">	<span class="comment">// the system is fully loaded so no spinning threads are required.</span></span><br><span class="line">	<span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span><br><span class="line">	<span class="comment">// 这里要非常小心: 线程从 spinning 到 non-spinning 状态的转换，可能与新 goroutine 的提交同时发生。 我们必须首先降低 nmspinning，</span></span><br><span class="line">	<span class="comment">// 然后再次检查所有的 per-P 队列（并在期间伴随 #StoreLoad 内存屏障）。如果反过来，其他线程可以在我们检查了所有的队列、然后提交一个</span></span><br><span class="line">	<span class="comment">//  goroutine、再降低 nmspinning ，进而导致无法 unpark 一个线程来运行那个 goroutine 了。</span></span><br><span class="line">	<span class="comment">// 如果我们发现下面的新 work，我们需要恢复 m.spinning 作为重置的信号，以取消 park 新的工作线程（因为可能有多个饥饿的 goroutine）。</span></span><br><span class="line">	<span class="comment">// 但是，如果在发现新 work 后我们也观察到没有空闲 P，可以暂停当前线程。因为系统已满载，因此不需要 spinning 线程。</span></span><br><span class="line">	<span class="comment">// 请参考此文件顶部 "工作线程 parking/unparking" 的注释。</span></span><br><span class="line">	wasSpinning := _g_.m.spinning <span class="comment">// 记录下之前的状态是否为 spinning</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		<span class="comment">//  spinning 到 non-spinning 状态的转换，并递减 sched.nmspinning</span></span><br><span class="line">		_g_.m.spinning = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check all runqueues once again</span></span><br><span class="line">	<span class="comment">// 再次检查所有的 runqueue</span></span><br><span class="line">	<span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">		<span class="comment">// 如果这时本地队列不空</span></span><br><span class="line">		<span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">			<span class="comment">// 锁住调度，重新获取空闲的 p</span></span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="comment">// 如果能获取到空闲的 p</span></span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">//  p 与当前 m 关联</span></span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				<span class="comment">// 如果此前已经被切换为 spinning</span></span><br><span class="line">				<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">					<span class="comment">// 重新切换回 non-spinning</span></span><br><span class="line">					_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">					atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 这时候是有 work 的，回到顶部重新找 g</span></span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 没有空闲的 p，不需要重新找 g 了</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for idle-priority GC work again.</span></span><br><span class="line">	<span class="comment">// 再次检查 idle-priority GC work 。和上面重新找 runqueue 的逻辑类似</span></span><br><span class="line">	<span class="comment">//  gcMarkWorkAvailable 参数为 nil ，在这种情况下，它仅检查全局工作任务。</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="comment">// 获取空闲的 p</span></span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 获取到的 p 没有 background mask worker， 重新放回空闲 p 列表</span></span><br><span class="line">			pidleput(_p_)</span><br><span class="line">			_p_ = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="comment">// 如果能获取到空闲的 p</span></span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//  p 与当前 m 关联</span></span><br><span class="line">			acquirep(_p_)</span><br><span class="line">			<span class="comment">// 如果此前已经被切换为 spinning</span></span><br><span class="line">			<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">				<span class="comment">// 重新切换回 non-spinning</span></span><br><span class="line">				_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">				atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Go back to idle GC check.</span></span><br><span class="line">			<span class="comment">// 这时候是有 work 的，回到顶部重新找 g</span></span><br><span class="line">			<span class="keyword">goto</span> stop</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poll network</span></span><br><span class="line">	<span class="comment">//  poll 网络。和上面重新找 runqueue 的逻辑类似</span></span><br><span class="line">	<span class="comment">// netpoll 已经初始化了，并且没有在等待 netpoll 的 g ，并且 sched.lastpoll != 0 ，满足的话，会设置 sched.lastpoll = 0</span></span><br><span class="line">	<span class="comment">//  atomic.Xchg64(&amp;sched.lastpoll, 0) 设置 sched.lastpoll = 0 ， 并返回原来的 sched.lastpoll</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		list := netpoll(<span class="literal">true</span>)                               <span class="comment">// block until new work is available // 阻塞直到有新的 work</span></span><br><span class="line">		atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime())) <span class="comment">// 存储上一次 netpool 时间</span></span><br><span class="line">		<span class="comment">//  netpoll 的 g list 不会空</span></span><br><span class="line">		<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="comment">// 获取空闲的 p</span></span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="comment">// 如果能获取到空闲的 p</span></span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">//  p 与当前 m 关联</span></span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				gp := list.pop()                      <span class="comment">// 获取一个</span></span><br><span class="line">				injectglist(&amp;list)                    <span class="comment">// 将 netpool 中剩余的 runnable g 列表插入到调度器中</span></span><br><span class="line">				casgstatus(gp, _Gwaiting, _Grunnable) <span class="comment">// 设置状态为 _Grunnable</span></span><br><span class="line">				<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">					traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 返回从 netpoll 中窃取到的 g</span></span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果没有获取到 p ，将 netpool 中获取到的 runnable g 列表插入到调度器中</span></span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确实找不到，park 当前的 m</span></span><br><span class="line">	stopm()</span><br><span class="line">	<span class="comment">//  m unpark 后继续找</span></span><br><span class="line">	<span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;schedule 大致的执行流程是：</p>
<ol>
<li>如果当前 M 锁定了某个 G ，那么应该交出P，进入休眠。等待某个 M 调度拿到 lockedg ，然后唤醒 lockedg 的 M</li>
<li>如果当前 GC 需要（STW), 则调用 gcstopm 休眠当前的 M</li>
<li>如果有安全点函数， 则执行</li>
<li>找一个 g 来执行，找 g 的过程大致如下：<ol>
<li>如果当前 GC 正在标记阶段，允许置黑对象，则查找有没有待运行的 GC Worker, GC Worker 也是一个 G</li>
<li>调度器每调度 61 次的时候，都会尝试从全局队列里取出待运行的 goroutine 来运行，调用 globrunqget</li>
<li>调用 runqget 从 P 本地可运行队列先选出一个可运行的 goroutine 。</li>
<li>调用 findrunnable 尝试从其他的 P 偷取、从本地或者全局队列中获取、pollnet ，如果没找到会 pack 。如果没找到则调用 stopm 来 park m ，等到有任务的时候唤醒。</li>
</ol>
</li>
<li>调用  execute(gp, inheritTime) 开始执行 g 。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules gp to run on the current M.</span></span><br><span class="line"><span class="comment">// If inheritTime is true, gp inherits the remaining time in the</span></span><br><span class="line"><span class="comment">// current time slice. Otherwise, it starts a new time slice.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed because this is called immediately after</span></span><br><span class="line"><span class="comment">// acquiring a P in several places.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在当前 M 上调度 gp。 如果 inheritTime 为 true，则 gp 继承剩余的时间片。否则从一个新的时间片开始。 此函数永不返回。</span></span><br><span class="line"><span class="comment">// 该函数允许 write barrier 因为它是在 acquire P 之后的调用的。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 g 正式切换为 _Grunning 状态</span></span><br><span class="line">	casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">	gp.waitsince = <span class="number">0</span>                           <span class="comment">// 清除等待时间，现在开始执行了</span></span><br><span class="line">	gp.preempt = <span class="literal">false</span>                         <span class="comment">// 关闭抢占</span></span><br><span class="line">	gp.stackguard0 = gp.stack.lo + _StackGuard <span class="comment">// 设置栈边界检测</span></span><br><span class="line">	<span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">		<span class="comment">// 如果不继承时间片，则开始新的</span></span><br><span class="line">		_g_.m.p.ptr().schedtick++</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.curg = gp <span class="comment">// 设置当前循运行的 g</span></span><br><span class="line">	gp.m = _g_.m    <span class="comment">// 设置运行的g的 m</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check whether the profiler needs to be turned on or off.</span></span><br><span class="line">	<span class="comment">// 检查是否需要打开或关闭 cpu profiler 。</span></span><br><span class="line">	hz := sched.profilehz</span><br><span class="line">	<span class="keyword">if</span> _g_.m.profilehz != hz &#123;</span><br><span class="line">		setThreadCPUProfiler(hz)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// trace</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// GoSysExit has to happen when we have a P, but before GoStart.</span></span><br><span class="line">		<span class="comment">// So we emit it here.</span></span><br><span class="line">		<span class="keyword">if</span> gp.syscallsp != <span class="number">0</span> &amp;&amp; gp.sysblocktraced &#123;</span><br><span class="line">			traceGoSysExit(gp.sysexitticks)</span><br><span class="line">		&#125;</span><br><span class="line">		traceGoStart()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从gobuf恢复状态，开始执行，gogo 实现在 asm_amd64.s 中</span></span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;execute 这里首先将 p 的状态改为 <code>_Grunning</code> ，然年绑定 m 和 p ，让后调用 gogo(&amp;gp.sched) 来执行 g 。 gogo 是由汇编实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line"><span class="comment">// func gogo(buf *gobuf)</span></span><br><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line"><span class="comment">// 从 Gobuf 恢复状态; longjmp</span></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">	MOVQ	buf+<span class="number">0</span>(FP), BX							<span class="comment">// gobuf //  BX = buf 运行现场</span></span><br><span class="line">	MOVQ	gobuf_g(BX), DX							<span class="comment">//  DX = buf.g</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(DX), CX		<span class="comment">// make sure g != nil 	// 确保 g != nil</span></span><br><span class="line">	get_tls(CX)										<span class="comment">//  CX = 当前 p</span></span><br><span class="line">	MOVQ	DX, g(CX)								<span class="comment">// 当前 g.g = buf.g</span></span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	<span class="comment">// restore SP		// SP = buf.sp</span></span><br><span class="line">	MOVQ	gobuf_ret(BX), AX						<span class="comment">// AX = buf.ret</span></span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX						<span class="comment">// DX = buf.ctxt</span></span><br><span class="line">	MOVQ	gobuf_bp(BX), BP						<span class="comment">// BP = buf.bp</span></span><br><span class="line">	MOVQ	$<span class="number">0</span>, gobuf_sp(BX)	<span class="comment">// clear to help garbage collector 	// buf.sp = 0 清理数据有助于 GC</span></span><br><span class="line">	MOVQ	$<span class="number">0</span>, gobuf_ret(BX)						<span class="comment">// buf.ret = 0</span></span><br><span class="line">	MOVQ	$<span class="number">0</span>, gobuf_ctxt(BX)						<span class="comment">// buf.ctxt = 0</span></span><br><span class="line">	MOVQ	$<span class="number">0</span>, gobuf_bp(BX)						<span class="comment">// buf.bp = 0</span></span><br><span class="line">	MOVQ	gobuf_pc(BX), BX 						<span class="comment">// BX = buf.pc 获取 g 要执行的函数的入口地址</span></span><br><span class="line">	JMP	BX											<span class="comment">// 跳转到对应的 buf.pc ，开始执行</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;gogo 中重点在 <code>MOVQ   gobuf_pc(BX), BX</code> ， 这个 pc 值是 gp 将要执行的指令，在初始化中，也就是 runtime.main 的第一条指令，然后 <code>JMP BX</code> 开始执行。</p>
<p>&emsp;&emsp;OK 到这里， runtime·main 终于动起来了，我们来看看 runtime.main 吧 ， 看看啥时候能运行行用户代码 <code>package main</code> 中的 main 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="comment">//  主 goroutine，也就是runtime·mainPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前的G, G为TLS(Thread Local Storage)</span></span><br><span class="line">	g := getg()</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</span></span><br><span class="line">	<span class="comment">// Using decimal instead of binary GB and MB because</span></span><br><span class="line">	<span class="comment">// they look nicer in the stack overflow failure message.</span></span><br><span class="line">	<span class="comment">// 执行栈的最大限制： 1GB on 64-bit， 250 MB on 32-bit。使用十进制而不是二进制GB和MB，因为它们在堆栈溢出失败消息中好看些。</span></span><br><span class="line">	<span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">1000000000</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		maxstacksize = <span class="number">250000000</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line">	<span class="comment">// 表示main goroutine启动了，接下来允许 newproc 启动新的 m</span></span><br><span class="line">	mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 runtime.main 函数的 G 必须是绑定在 m0 上的</span></span><br><span class="line">	<span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">		throw(<span class="string">"runtime.main not on m0"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  执行初始化运行时</span></span><br><span class="line">	runtime_init() <span class="comment">// must be before defer //  defer 必须在此调用结束后才能使用</span></span><br><span class="line">	<span class="keyword">if</span> nanotime() == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"nanotime returning zero"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">	main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 main_init，进行间接调用，因为链接器在设定运行时的时候不知道 main 包的地址</span></span><br><span class="line">	fn := main_init <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line">	<span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">	needUnlock = <span class="literal">false</span></span><br><span class="line">	unlockOSThread()</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行用户 main 包中的 main 函数，处理为非间接调用，因为链接器在设定运行时不知道 main 包的地址</span></span><br><span class="line">	fn = main_main <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 退出执行，返回退出状态码</span></span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;runtime·main 限制了最大栈（近似 1GB on 64-bit， 250 MB on 32-bit），结合前面的，我们就知道了， go 动态栈的范围是 2KB 到 1GB/250MB 。然后 <code>fn = main_main ; fn()</code> 终于执行到用户代码了，真不容易啊！然后直接调用 exit 结束进程了。注意这里是 main goroutine !</p>
<p>&emsp;&emsp;咦，咋就这么结束了？还有其它的 goroutine 呢？ 都不管了？</p>
<p>&emsp;&emsp;我们回忆以下，main goroutine 的入口函数是 runtime·mainPC 也就是 runtime.main 函数，通过 <code>schedule() -&gt; execute() -&gt; gogo()</code> 中 gogo 函数用汇编跳转的，后面没有指令了，返回到哪里？。另外 runtime.main 会等用户代码执行完返回，我们用户代码返回了，这里 exit 也合情合理。 </p>
<p>&emsp;&emsp;之前有分析过， newproc1 的 <code>newg.sched.pc = funcPC(goexit) + sys.PCQuantum</code> 的时候有伪造 goexit 函数调用 goroutine 的入口函数，上面说分析了 main goroutine 直接退出了， 非 main goroutine 执行完成后就会返回到 goexit 继续执行， 我们来看看非 main goroutine的后续处理 goexit 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line"><span class="comment">// 在 goroutine 上运行的最顶层函数将返回goexit + PCQuantum。</span></span><br><span class="line"><span class="comment">// goroutine 执行完成后返回后执行： CALL	runtime·goexit1(SB)</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">	BYTE	$<span class="number">0x90</span>	<span class="comment">// NOP</span></span><br><span class="line">	CALL	runtime·goexit1(SB)	<span class="comment">// does not return  // 永不返回</span></span><br><span class="line">	<span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">	BYTE	$<span class="number">0x90</span>	<span class="comment">// NOP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="comment">// 完成当前 goroutine 的执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racegoend()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoEnd()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 开始收尾工作</span></span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;之前分析过， gostartcallfn 是把 goexit 函数的第二条指令的地址入栈，伪造成 goexit 函数调用了 fn ，也就是这里的 runtime·goexit1 函数，goexit1 调用到 mcall(goexit0) 了， mcall 切换到 g0 然后执行 goexit0 ，这里再继续可能看 goexit0 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="comment">//  goexit 继续在 g0 上执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切换当前的 g 为 _Gdead</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">	<span class="comment">// 如果是系统 g ， 更新统计信息</span></span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清理</span></span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">	gp.lockedm = <span class="number">0</span></span><br><span class="line">	_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">	gp.paniconfault = <span class="literal">false</span></span><br><span class="line">	gp._defer = <span class="literal">nil</span> <span class="comment">// should be true already but just in case. // 应该已经为 true，但以防万一</span></span><br><span class="line">	gp._panic = <span class="literal">nil</span> <span class="comment">// non-nil for Goexit during panic. points at stack-allocated data. //  Goexit 中 panic 则不为 nil， 指向栈分配的数据</span></span><br><span class="line">	gp.writebuf = <span class="literal">nil</span></span><br><span class="line">	gp.waitreason = <span class="number">0</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Flush assist credit to the global pool. This gives</span></span><br><span class="line">		<span class="comment">// better information to pacing if the application is</span></span><br><span class="line">		<span class="comment">// rapidly creating an exiting goroutines.</span></span><br><span class="line">		<span class="comment">// 刷新 assist credit 到全局池。如果政协在快速创建已存在的 goroutine，这可以为 pacing 提供更好的信息。</span></span><br><span class="line">		scanCredit := <span class="keyword">int64</span>(gcController.assistWorkPerByte * <span class="keyword">float64</span>(gp.gcAssistBytes))</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">		gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note that gp's stack scan is now "valid" because it has no</span></span><br><span class="line">	<span class="comment">// stack.</span></span><br><span class="line">	<span class="comment">// 请注意， gp 的栈扫描现在 “有效” ，因为它没有栈。</span></span><br><span class="line">	gp.gcscanvalid = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 移除 m 与当前 goroutine m-&gt;curg 之间的关联</span></span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> GOARCH == <span class="string">"wasm"</span> &#123; <span class="comment">// no threads yet on wasm //  wasm 目前还没有线程支持</span></span><br><span class="line">		gfput(_g_.m.p.ptr(), gp) <span class="comment">// 将 g 放进 gfree 链表中等待复用</span></span><br><span class="line">		schedule()               <span class="comment">// never returns</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  lockOSThread/unlockOSThread 调用不匹配</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"invalid m-&gt;lockedInt = "</span>, _g_.m.lockedInt, <span class="string">"\n"</span>)</span><br><span class="line">		throw(<span class="string">"internal lockOSThread error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gfput(_g_.m.p.ptr(), gp) <span class="comment">// 将 g 放进 gfree 链表中等待复用</span></span><br><span class="line">	<span class="keyword">if</span> locked &#123;</span><br><span class="line">		<span class="comment">// The goroutine may have locked this thread because</span></span><br><span class="line">		<span class="comment">// it put it in an unusual kernel state. Kill it</span></span><br><span class="line">		<span class="comment">// rather than returning it to the thread pool.</span></span><br><span class="line">		<span class="comment">// 该 goroutine 可能在当前线程上锁住，因为它可能导致了不正常的内核状态。这时候 kill 该线程，而非将 m 放回到线程池。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Return to mstart, which will release the P and exit</span></span><br><span class="line">		<span class="comment">// the thread.</span></span><br><span class="line">		<span class="comment">// 此举会返回到 mstart，从而释放当前的 P 并退出该线程</span></span><br><span class="line">		<span class="keyword">if</span> GOOS != <span class="string">"plan9"</span> &#123; <span class="comment">// See golang.org/issue/22227.</span></span><br><span class="line">			<span class="comment">//  mstart1 调用 save 保存的，这里恢复，则结束线程</span></span><br><span class="line">			gogo(&amp;_g_.m.g0.sched)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Clear lockedExt on plan9 since we may end up re-using</span></span><br><span class="line">			<span class="comment">// this thread.</span></span><br><span class="line">			<span class="comment">// 因为我们可能已重用此线程结束，在 plan9 上清除 lockedExt</span></span><br><span class="line">			_g_.m.lockedExt = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再次进行调度</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从上面我们可以看出，goexit0 主要是做一些清理工作，然后调用 schedule 继续调度。主要如下：</p>
<ol>
<li>将g 的状态从 <code>_Grunning</code> 变更为 <code>_Gdead</code></li>
<li>清零 g 的一些字段</li>
<li>调用 dropg 移除 m 与当前 goroutine m-&gt;curg 之间的关联</li>
<li>调用 gfput(<em>g</em>.m.p.ptr(), gp) 将 g 放进 gfree 链表中等待复用</li>
<li>调用 schedule 再次进行调度。</li>
</ol>
<p>&emsp;&emsp;至此，GO schedule 基本分析完了， Go Start The World !</p>
<p>&emsp;&emsp;那么我们这里总结一下：</p>
<p><img src="/2020/02/02/【golang源码分析】之GPM调度/GPM%E8%B0%83%E5%BA%A6.jpg" alt="GPM 调度"></p>
<p>&emsp;&emsp;如图所示，rt0_go 负责 Go 程序启动的所有初始化，中间进行了很多初始化工作，调用 mstart 之前，已经切换到了 g0 栈，图中不同色块表示使用不同的栈空间。</p>
<p>&emsp;&emsp;接着调用 gogo 函数，完成从 g0 栈到用户 goroutine 栈的切换，包括 main goroutine 和普通 goroutine。</p>
<p>&emsp;&emsp;之后，执行 main 函数或者用户自定义的 goroutine 任务。</p>
<p>&emsp;&emsp;执行完成后，main goroutine 直接调用 eixt(0) 退出，普通 goroutine 则调用 goexit -&gt; goexit1 -&gt; mcall，完成普通 goroutine 退出后的清理工作，然后切换到 g0 栈，调用 goexit0 函数，将普通 goroutine 添加到缓存池中，再调用 schedule 函数进行新一轮的调度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schedule() -&gt; execute() -&gt; gogo() -&gt; goroutine 任务 -&gt; </span><br><span class="line">goexit() -&gt; goexit1() -&gt; mcall() -&gt; goexit0() -&gt; schedule()</span><br></pre></td></tr></table></figure>

<h3 id="GPM-状态转变"><a href="#GPM-状态转变" class="headerlink" title="GPM 状态转变"></a>GPM 状态转变</h3><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p><img src="/2020/02/02/【golang源码分析】之GPM调度/M%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg" alt="M状态转变"></p>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p><img src="/2020/02/02/【golang源码分析】之GPM调度/P%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg" alt="M状态转变"></p>
<h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p><img src="/2020/02/02/【golang源码分析】之GPM调度/G%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg" alt="M状态转变"></p>

    </div>

    
    
    
      
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-handshake-o"></i>感谢您的阅读-------------</div>
    
</div>

        
      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Vee Zhang</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/" title="【golang源码分析】之GPM调度">https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/01/29/【golang源码分析】之GPM概述/" rel="next" title="【golang源码分析】之GPM概述">
                  <i class="fa fa-chevron-left"></i> 【golang源码分析】之GPM概述
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的入口"><span class="nav-number">1.1.</span> <span class="nav-text">程序的入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-g0"><span class="nav-number">1.2.</span> <span class="nav-text">初始化 g0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程绑定-m0"><span class="nav-number">1.3.</span> <span class="nav-text">主线程绑定 m0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化m0"><span class="nav-number">1.4.</span> <span class="nav-text">初始化m0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化allp"><span class="nav-number">1.5.</span> <span class="nav-text">初始化allp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建main-goroutine"><span class="nav-number">1.6.</span> <span class="nav-text">创建main goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始调度循环"><span class="nav-number">1.7.</span> <span class="nav-text">开始调度循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GPM-状态转变"><span class="nav-number">1.8.</span> <span class="nav-text">GPM 状态转变</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#M"><span class="nav-number">1.8.1.</span> <span class="nav-text">M</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P"><span class="nav-number">1.8.2.</span> <span class="nav-text">P</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G"><span class="nav-number">1.8.3.</span> <span class="nav-text">G</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/uploads/v.jpeg"
      alt="Vee Zhang">
  <p class="site-author-name" itemprop="name">Vee Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/veezhang" title="GitHub &rarr; https://github.com/veezhang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="/veezhang@126.com" title="E-Mail &rarr; veezhang@126.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vee Zhang</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  


  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
