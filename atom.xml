<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vee Zhang</title>
  
  <subtitle>一个奋斗在IT界的Coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://veezhang.github.io/"/>
  <updated>2020-05-15T08:26:44.374Z</updated>
  <id>https://veezhang.github.io/</id>
  
  <author>
    <name>Vee Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【golang源码分析】之GPM调度</title>
    <link href="https://veezhang.github.io/2020/02/02/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8BGPM%E8%B0%83%E5%BA%A6/"/>
    <id>https://veezhang.github.io/2020/02/02/【golang源码分析】之GPM调度/</id>
    <published>2020-02-02T08:54:23.000Z</published>
    <updated>2020-05-15T08:26:44.374Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上一篇 <a href>【golang源码分析】之GPM概述</a> ，我们介绍 GPM 的一些基础概念，这里将是重点，梳理 GMP 的调度流程。其实在 <a href="https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/#more">【golang源码分析】之启动追踪</a> 中以及梳理了一下启动流程，涉及到的地方，这里会简要的过一下。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="程序的入口"><a href="#程序的入口" class="headerlink" title="程序的入口"></a>程序的入口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/rt0_linux_amd64.s</span></span><br><span class="line"><span class="comment">//  linux amd64 系统的启动函数</span></span><br><span class="line">TEXT _rt0_amd64_linux(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">    JMP _rt0_amd64(SB) <span class="comment">// 跳转到_rt0_amd64函数， 在 asm_amd64.s 中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), DI   <span class="comment">// argc     //  设置参数argc</span></span><br><span class="line">    LEAQ    <span class="number">8</span>(SP), SI   <span class="comment">// argv     //  设置参数argv</span></span><br><span class="line">    JMP runtime·rt0_go(SB)          <span class="comment">//  跳转到runtime·rt0_go</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>然后会调用 runtime·rt0_go 来初始化，是非常核心的代码。</p><h3 id="初始化-g0"><a href="#初始化-g0" class="headerlink" title="初始化 g0"></a>初始化 g0</h3><p>&emsp;&emsp;g0 的主要作用是提供一个栈供 runtime 代码执行，因此这里主要对 g0 的几个与栈有关的成员进行了初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// create istack out of the given (operating system) stack.</span></span><br><span class="line"><span class="comment">// _cgo_init may update stackguard.</span></span><br><span class="line"><span class="comment">// 从给定（操作系统）栈中创建 istack 。 _cgo_init 可能更新 stackguard</span></span><br><span class="line"><span class="comment">// runtime.g0 位于 runtime/proc.go</span></span><br><span class="line"><span class="comment">// 初始化 g0，g0 的栈实际上就是 linux 分配的栈，大约 64k。</span></span><br><span class="line">MOVQ$runtime·g0(SB), DI<span class="comment">//  DI = runtime·g0</span></span><br><span class="line">LEAQ(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX<span class="comment">//  BX = SP-64*1024+104</span></span><br><span class="line">MOVQBX, g_stackguard0(DI)<span class="comment">//  g0.stackguard0 = SP-64*1024+104</span></span><br><span class="line">MOVQBX, g_stackguard1(DI)<span class="comment">//  g0.stackguard1 = g0.stackguard0</span></span><br><span class="line">MOVQBX, (g_stack+stack_lo)(DI)<span class="comment">//  g0.stack.lo = g0.stackguard0</span></span><br><span class="line">MOVQSP, (g_stack+stack_hi)(DI)<span class="comment">//  g0.stack.hi = SP</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="主线程绑定-m0"><a href="#主线程绑定-m0" class="headerlink" title="主线程绑定 m0"></a>主线程绑定 m0</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置tls， Thread Local Storage</span></span><br><span class="line">LEAQruntime·m0+m_tls(SB), DI<span class="comment">//  DI = m0.tls ，这个会在 runtime·settls 中使用</span></span><br><span class="line">CALLruntime·settls(SB)<span class="comment">// 调用 runtime·settls</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the per-goroutine and per-mach "registers"</span></span><br><span class="line"><span class="comment">// 将 g0 放到 tls 里，这里实际上就是 m0.tls</span></span><br><span class="line">get_tls(BX)<span class="comment">// 等价于 MOVQ TLS, BX 。 从 TLS 起始移动 8 byte 值到 BX 寄存器，获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址</span></span><br><span class="line">LEAQruntime·g0(SB), CX<span class="comment">// CX=g0</span></span><br><span class="line">MOVQCX, g(BX)<span class="comment">// 等价于 MOVQ CX， 0(BX)(TLS*1),  也就是m0.tls[0] = g0</span></span><br><span class="line">LEAQruntime·m0(SB), AX<span class="comment">// AX=m0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">MOVQCX, m_g0(AX)<span class="comment">// m0.g0 = g0</span></span><br><span class="line"><span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">MOVQAX, g_m(CX)<span class="comment">// g0.m = m0</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码首先把 g0 的地址放入主线程的 TLS 中，然后通过 <code>m0.g0 = &amp;g0, g0.m = &amp;m0</code> 把 m0 和 g0 绑定在一起，这样，之后在主线程中通过 get_tls 可以获取到 g0 ，通过 g0 的 m 成员又可以找到 m0 ，于是这里就实现了m0和g0与主线程之间的关联。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CALLruntime·osinit(SB)<span class="comment">// 初始化 os ，在 os_linux.go</span></span><br><span class="line">CALLruntime·schedinit(SB)<span class="comment">// 初始化 sched ，在 proc.go</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;osinit 主要是初始化 ncpu ， schedinit 是核心的初始化。</p><h3 id="初始化m0"><a href="#初始化m0" class="headerlink" title="初始化m0"></a>初始化m0</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//call osinit</span></span><br><span class="line"><span class="comment">//call schedinit</span></span><br><span class="line"><span class="comment">//make &amp; queue new G</span></span><br><span class="line"><span class="comment">//call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br><span class="line"><span class="comment">// 启动顺序</span></span><br><span class="line"><span class="comment">// 调用 osinit</span></span><br><span class="line"><span class="comment">// 调用 schedinit</span></span><br><span class="line"><span class="comment">// make &amp; queue new G</span></span><br><span class="line"><span class="comment">// 调用 runtime·mstart</span></span><br><span class="line"><span class="comment">// 创建 G 的调用 runtime·main.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 初始化sched, 核心部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">_g_ := getg() <span class="comment">// _g_ = g0</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大系统线程数量（即 M），参考标准库 runtime/debug.SetMaxThreads</span></span><br><span class="line">sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mcommoninit(_g_.m) <span class="comment">// 初始化当前 M</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络的上次轮询时间</span></span><br><span class="line">sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line"><span class="comment">// 设置procs， 根据cpu核数和环境变量GOMAXPROCS， 优先环境变量</span></span><br><span class="line">procs := ncpu</span><br><span class="line"><span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">procs = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整 P 的数量，这时所有 P 均为新建的 P，因此不能返回有本地任务的 P</span></span><br><span class="line"><span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;g0 的地址已经被设置到了 TLS 之中，<code>_g_ := getg()</code> 获取的为 g0 ，<code>mcommoninit(_g_.m)</code> 即为初始化 m0 ，这里我们先关注下 mcommoninit 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// 通用初始化 M</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// g0 stack won't make sense for user (and is not necessary unwindable).</span></span><br><span class="line"><span class="comment">// 检查当前 g 是否是 g0，g0 栈对用户而言是没有意义的（且不是不可避免的）</span></span><br><span class="line"><span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">callers(<span class="number">1</span>, mp.createstack[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁住调度器</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 确保线程数量不会太多而溢出</span></span><br><span class="line"><span class="keyword">if</span> sched.mnext+<span class="number">1</span> &lt; sched.mnext &#123;</span><br><span class="line">throw(<span class="string">"runtime: thread ID overflow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mnext 表示当前 m 的数量，还表示下一个 m 的 id</span></span><br><span class="line">mp.id = sched.mnext</span><br><span class="line"><span class="comment">// 增加 m 的数量</span></span><br><span class="line">sched.mnext++</span><br><span class="line"><span class="comment">// 检测 m 的数量</span></span><br><span class="line">checkmcount()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 fastrand 快速取随机数</span></span><br><span class="line">mp.fastrand[<span class="number">0</span>] = <span class="number">1597334677</span> * <span class="keyword">uint32</span>(mp.id)</span><br><span class="line">mp.fastrand[<span class="number">1</span>] = <span class="keyword">uint32</span>(cputicks())</span><br><span class="line"><span class="keyword">if</span> mp.fastrand[<span class="number">0</span>]|mp.fastrand[<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">mp.fastrand[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 gsignal，用于处理 m 上的信号。</span></span><br><span class="line">mpreinit(mp)</span><br><span class="line"><span class="comment">// gsignal 的运行栈边界处理</span></span><br><span class="line"><span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add to allm so garbage collector doesn't free g-&gt;m</span></span><br><span class="line"><span class="comment">// when it is just in a register or thread-local storage.</span></span><br><span class="line"><span class="comment">// 添加到 allm 中，从而当它刚保存到寄存器或本地线程存储时候 GC 不会释放 g-&gt;m</span></span><br><span class="line"><span class="comment">// 每一次调用都会将 allm 给 alllink，给完之后自身被 mp 替换，在下一次的时候又给 alllink ，从而形成链表</span></span><br><span class="line">mp.alllink = allm</span><br><span class="line"></span><br><span class="line"><span class="comment">// NumCgoCall() iterates over allm w/o schedlock,</span></span><br><span class="line"><span class="comment">// so we need to publish it safely.</span></span><br><span class="line"><span class="comment">// NumCgoCall() 会在没有使用 schedlock 时遍历 allm，因此我们需要安全的修改。</span></span><br><span class="line"><span class="comment">// 等价于 allm = mp</span></span><br><span class="line">atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line"><span class="comment">//  m 的通用初始化完成，解锁调度器</span></span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory to hold a cgo traceback if the cgo call crashes.</span></span><br><span class="line"><span class="comment">// 分配内存来保存当 cgo 调用崩溃时候的回溯</span></span><br><span class="line"><span class="keyword">if</span> iscgo || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mcommoninit 并未对 m0 做什么关于调度相关的初始化，只是将 m0 放入全局链表 allm 之中。</p><h3 id="初始化allp"><a href="#初始化allp" class="headerlink" title="初始化allp"></a>初始化allp</h3><p>&emsp;&emsp;然后我们在关注 procresize 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class="line"><span class="comment">// gcworkbufs are not being modified by either the GC or</span></span><br><span class="line"><span class="comment">// the write barrier code.</span></span><br><span class="line"><span class="comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class="line"><span class="comment">// 修改 P 的数量，此时所有工作均被停止 STW，sched 被锁定。 gcworkbufs 既不会被 GC 修改，也不会被 write barrier 修改。</span></span><br><span class="line"><span class="comment">// 返回带有 local work 的 P 列表，他们需要被调用方调度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取之前的 P 个数</span></span><br><span class="line">old := gomaxprocs</span><br><span class="line"><span class="comment">// 边界检查</span></span><br><span class="line"><span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"procresize: invalid arg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trace 相关</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGomaxprocs(nprocs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update statistics</span></span><br><span class="line"><span class="comment">// 更新统计信息，记录此次修改 gomaxprocs 的时间</span></span><br><span class="line">now := nanotime()</span><br><span class="line"><span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">sched.totaltime += <span class="keyword">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">&#125;</span><br><span class="line">sched.procresizetime = now</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow allp if necessary.</span></span><br><span class="line"><span class="comment">// 必要时增加 allp</span></span><br><span class="line"><span class="comment">// 这个时候本质上是在检查用户代码是否有调用过 runtime.MAXGOPROCS 调整 p 的数量。</span></span><br><span class="line"><span class="comment">// 此处多一步检查是为了避免内部的锁，如果 nprocs 明显小于 allp 的可见数量，则不需要进行加锁</span></span><br><span class="line"><span class="keyword">if</span> nprocs &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line"><span class="comment">// Synchronize with retake, which could be running</span></span><br><span class="line"><span class="comment">// concurrently since it doesn't run on a P.</span></span><br><span class="line"><span class="comment">// 此处与 retake 同步，它可以同时运行，因为它不会在 P 上运行。</span></span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line"><span class="keyword">if</span> nprocs &lt;= <span class="keyword">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line"><span class="comment">// 如果 allp 容量足够，去切片就好了</span></span><br><span class="line">allp = allp[:nprocs]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则 allp 容量不够，重新申请</span></span><br><span class="line">nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line"><span class="comment">// Copy everything up to allp's cap so we</span></span><br><span class="line"><span class="comment">// never lose old allocated Ps.</span></span><br><span class="line"><span class="comment">// 将所有内容复制到 allp 的上，这样我们就永远不会丢失旧分配的P 。</span></span><br><span class="line"><span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">allp = nallp</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize new P's</span></span><br><span class="line"><span class="comment">// 初始化新的 P</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">pp := allp[i]</span><br><span class="line"><span class="comment">// 如果 p 是新创建的(新创建的 p 在数组中为 nil)，则申请新的 P 对象</span></span><br><span class="line"><span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">pp = <span class="built_in">new</span>(p)</span><br><span class="line">pp.id = i            <span class="comment">//  p 的 id 就是它在 allp 中的索引</span></span><br><span class="line">pp.status = _Pgcstop <span class="comment">// 新创建的 p 处于 _Pgcstop 状态</span></span><br><span class="line">pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">pp.wbBuf.reset()</span><br><span class="line">atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为 P 分配 cache 对象</span></span><br><span class="line"><span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果 old == 0 且 i == 0 说明这是引导阶段初始化第一个 p 。schedinit 中 mallocinit 有初始化一个 mcache</span></span><br><span class="line"><span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 确认当前 g 的 m 的 mcache 非空</span></span><br><span class="line"><span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">&#125;</span><br><span class="line">pp.mcache = getg().m.mcache <span class="comment">// bootstrap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pp.mcache = allocmcache()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 启动了 race 并且 racectx 为 0，则新建</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; pp.racectx == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果 old == 0 且 i == 0 说明这是引导阶段初始化第一个 p 。 schedinit 中有初始化一个 raceproccreate</span></span><br><span class="line"><span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">pp.racectx = raceprocctx0</span><br><span class="line">raceprocctx0 = <span class="number">0</span> <span class="comment">// bootstrap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pp.racectx = raceproccreate()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// free unused P's</span></span><br><span class="line"><span class="comment">// 释放不用的 P</span></span><br><span class="line"><span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">p := allp[i]</span><br><span class="line"><span class="keyword">if</span> trace.enabled &amp;&amp; p == getg().m.p.ptr() &#123;</span><br><span class="line"><span class="comment">// moving to p[0], pretend that we were descheduled</span></span><br><span class="line"><span class="comment">// and then scheduled again to keep the trace sane.</span></span><br><span class="line"><span class="comment">// 移至 p[0] ，假装我们已被调度，然后再次调度以保持跟踪正常。</span></span><br><span class="line">traceGoSched()</span><br><span class="line">traceProcStop(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// move all runnable goroutines to the global queue</span></span><br><span class="line"><span class="comment">// 将所有的 runnable goroutines 移动到全局队列 sched.runq</span></span><br><span class="line"><span class="keyword">for</span> p.runqhead != p.runqtail &#123;</span><br><span class="line"><span class="comment">// pop from tail of local queue</span></span><br><span class="line"><span class="comment">// 从本地队列的尾部 pop</span></span><br><span class="line">p.runqtail--</span><br><span class="line">gp := p.runq[p.runqtail%<span class="keyword">uint32</span>(<span class="built_in">len</span>(p.runq))].ptr()</span><br><span class="line"><span class="comment">// push onto head of global queue</span></span><br><span class="line"><span class="comment">//  push 到全局队列的头部</span></span><br><span class="line">globrunqputhead(gp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 runnext 不为 0，也加入到全局队列 sched.runq</span></span><br><span class="line"><span class="keyword">if</span> p.runnext != <span class="number">0</span> &#123;</span><br><span class="line">globrunqputhead(p.runnext.ptr())</span><br><span class="line">p.runnext = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if there's a background worker, make it runnable and put</span></span><br><span class="line"><span class="comment">// it on the global queue so it can clean itself up</span></span><br><span class="line"><span class="comment">// 如果存在 gc 后台 worker，则让其 runnable 并将其放到全局队列中从而可以让其对自身进行清理</span></span><br><span class="line"><span class="keyword">if</span> gp := p.gcBgMarkWorker.ptr(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">globrunqput(gp)</span><br><span class="line"><span class="comment">// This assignment doesn't race because the</span></span><br><span class="line"><span class="comment">// world is stopped.</span></span><br><span class="line"><span class="comment">// 此赋值不会发生竞争，因为此时已经 STW</span></span><br><span class="line">p.gcBgMarkWorker.set(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Flush p's write barrier buffer.</span></span><br><span class="line"><span class="comment">// 刷新 p 的写屏障缓存</span></span><br><span class="line"><span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">wbBufFlush1(p)</span><br><span class="line">p.gcw.dispose()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 sudogbuf</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> p.sudogbuf &#123;</span><br><span class="line">p.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">p.sudogcache = p.sudogbuf[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> p.deferpool &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> p.deferpoolbuf[i] &#123;</span><br><span class="line">p.deferpoolbuf[i][j] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">p.deferpool[i] = p.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放当前 P 绑定的 mcache</span></span><br><span class="line">freemcache(p.mcache)</span><br><span class="line">p.mcache = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 将当前 P 的 G 复链转移到全局</span></span><br><span class="line">gfpurge(p)</span><br><span class="line">traceProcFree(p)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceprocdestroy(p.racectx)</span><br><span class="line">p.racectx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">p.gcAssistTime = <span class="number">0</span></span><br><span class="line">p.status = _Pdead</span><br><span class="line"><span class="comment">// can't free P itself because it can be referenced by an M in syscall</span></span><br><span class="line"><span class="comment">// 不能释放 P 本身，因为它可能被系统调用的 M 引用。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trim allp.</span></span><br><span class="line"><span class="comment">// 修剪 allp</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line">allp = allp[:nprocs]</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123; <span class="comment">// 当前的 P 不需要被释放</span></span><br><span class="line"><span class="comment">// continue to use the current P</span></span><br><span class="line"><span class="comment">// 继续使用当前 P</span></span><br><span class="line">_g_.m.p.ptr().status = _Prunning</span><br><span class="line">_g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// release the current P and acquire allp[0]</span></span><br><span class="line"><span class="comment">// 释放当前 P，然后获取 allp[0]</span></span><br><span class="line"><span class="comment">//  p 和 m 解绑</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">_g_.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">_g_.m.p = <span class="number">0</span></span><br><span class="line">_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 更换到 allp[0]</span></span><br><span class="line">p := allp[<span class="number">0</span>]</span><br><span class="line">p.m = <span class="number">0</span></span><br><span class="line">p.status = _Pidle</span><br><span class="line">acquirep(p) <span class="comment">// 直接将 allp[0] 绑定到当前的 M</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoStart()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> runnablePs *p</span><br><span class="line"><span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">p := allp[i]</span><br><span class="line"><span class="comment">// 确保不是当前正在使用的 P</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 p 设为 _Pidle</span></span><br><span class="line">p.status = _Pidle</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地任务列表是否为空</span></span><br><span class="line"><span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line"><span class="comment">// 放入 idle 链表</span></span><br><span class="line">pidleput(p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果有本地任务，则为其绑定一个 M（不一定能获取到）</span></span><br><span class="line">p.m.set(mget())</span><br><span class="line"><span class="comment">// 第一个循环为 nil，后续则为上一个 p，此处即为构建可运行的 p 链表</span></span><br><span class="line">p.link.set(runnablePs)</span><br><span class="line">runnablePs = p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stealOrder.reset(<span class="keyword">uint32</span>(nprocs))</span><br><span class="line"><span class="keyword">var</span> int32p *<span class="keyword">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32 // 让编译器检查 gomaxprocs 是 int32 类型</span></span><br><span class="line">atomic.Store((*<span class="keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="keyword">uint32</span>(nprocs))</span><br><span class="line"><span class="comment">// 让编译器检查 gomaxprocs 是 int32 类型</span></span><br><span class="line"><span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate p and the current m.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is allowed to have write barriers even if the caller</span></span><br><span class="line"><span class="comment">// isn't because it immediately acquires _p_.</span></span><br><span class="line"><span class="comment">// 将 p 关联到当前的 m 。因为该函数会立即 acquire P，因此即使调用方不允许 write barrier，此函数仍然允许 write barrier。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line"><span class="comment">// Do the part that isn't allowed to have write barriers.</span></span><br><span class="line"><span class="comment">// 此处不允许 write barrier 。关联了当前的 M 到 P 上。</span></span><br><span class="line">wirep(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Have p; write barriers now allowed. // 已经获取了 p，因此之后允许 write barrier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform deferred mcache flush before this P can allocate</span></span><br><span class="line"><span class="comment">// from a potentially stale mcache.</span></span><br><span class="line"><span class="comment">// 在此 P 可以从可能过时的 mcache 分配前执行延迟的 mcache flush</span></span><br><span class="line">_p_.mcache.prepareForSweep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceProcStart()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wirep is the first step of acquirep, which actually associates the</span></span><br><span class="line"><span class="comment">// current M to _p_. This is broken out so we can disallow write</span></span><br><span class="line"><span class="comment">// barriers for this part, since we don't yet have a P.</span></span><br><span class="line"><span class="comment">//  wirep 为 acquirep 的实际获取 p 的第一步，它关联了当前的 M 到 P 上。 我们在这部分使用 write barriers 被打破了，因为我们还没有P。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前的 m 已经关联了 p</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> || _g_.m.mcache != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"wirep: already in go"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 _p_ 已经关联了 m ， 且 _p_ 的状态不是 _Pidle</span></span><br><span class="line"><span class="keyword">if</span> _p_.m != <span class="number">0</span> || _p_.status != _Pidle &#123;</span><br><span class="line">id := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> _p_.m != <span class="number">0</span> &#123;</span><br><span class="line">id = _p_.m.ptr().id</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"wirep: p-&gt;m="</span>, _p_.m, <span class="string">"("</span>, id, <span class="string">") p-&gt;status="</span>, _p_.status, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"wirep: invalid p state"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关联当前 m 和 _p_ ， 并设置 _p_ 为 _Prunning</span></span><br><span class="line">_g_.m.mcache = _p_.mcache <span class="comment">// 使用 p 的 mcache</span></span><br><span class="line">_g_.m.p.set(_p_)          <span class="comment">// 将 p 关联到到 m</span></span><br><span class="line">_p_.m.set(_g_.m)          <span class="comment">// 将 m 关联到到 p</span></span><br><span class="line">_p_.status = _Prunning    <span class="comment">// 设置 _Prunning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数看起来比较长，其实并不复杂，主要流程是：</p><ol><li>初始化全局变量 allp ， <code>allp = make([]*p, nprocs)</code> ，可能存在复用和扩增之前的 allp ，由于这里是第一次初始化，所以仅仅是初始化。</li><li>初始化所有新的 P ， 包括 status(-&gt;<code>_Pgcstop</code>) ， sudogbuf , mcache 等。</li><li>释放不用的 P ，包括本地运行队列， sudogbuf ， mcache ， status(-&gt;<code>_Pdead</code>) 等。</li><li>如果有当前的 P 并且这个 P 不是被释放的，则设置状态改为 <code>_Prunning</code> ；否则设置为 <code>_Pidle</code> ， 然后调用 acquirep -&gt;wirep 又会将其状态设置为 <code>_Prunning</code> ，并且设置其 mcache 。由于这里还没初始化 m0-&gt;p ，所以会走后面的逻辑，此时 m0 和 allp[0] 绑定。</li><li>把其它的 P 设置为 <code>_Pidle</code> 状态并根据情况放置到 pidle 空闲队列之中，或者返回可运行的 P 。这里肯定是将其它所有的设置为 <code>_Pidle</code> 状态。</li></ol><p>&emsp;&emsp;至此，m0, g0 和 allp 都初始化完成了，那么怎么启动我们的 main 函数呢？ schedinit 中貌似并没有相关的代码。我们返回来看 runtime·rt0_go 后面做了什么事情。</p><h3 id="创建main-goroutine"><a href="#创建main-goroutine" class="headerlink" title="创建main goroutine"></a>创建main goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line"><span class="comment">// 创建 goroutine 并加入到等待队列，该 goroutine 执行 runtime.mainPC 所指向的函数</span></span><br><span class="line">MOVQ$runtime·mainPC(SB), AX<span class="comment">// entry//  入口函数 在 proc.go 中</span></span><br><span class="line">PUSHQAX<span class="comment">// 压栈，设置参数 runtime·newproc 的 fn</span></span><br><span class="line">PUSHQ$<span class="number">0</span><span class="comment">// arg size// 压栈，设置参数 runtime·newproc 的 siz</span></span><br><span class="line">CALLruntime·newproc(SB)<span class="comment">// 调用 runtime·newproc ，在 proc.go 函数原型： func newproc(siz int32, fn *funcval)</span></span><br><span class="line">POPQAX<span class="comment">// 弹出 PUSHQ$0</span></span><br><span class="line">POPQAX<span class="comment">// 弹出 PUSHQAX</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的变量 mainPC 为 runtime.main 函数的地址，该变量为 read only</span></span><br><span class="line">DATAruntime·mainPC+<span class="number">0</span>(SB)/<span class="number">8</span>,$runtime·main(SB)</span><br><span class="line">GLOBLruntime·mainPC(SB),RODATA,$<span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们可以看到，设置 runtime·mainPC 函数，然后调用 runtime·newproc 来创建 g ，注意此处的 runtime·mainPC 还不是我们写代码的 main 函数，而是 runtime 中定义的 main 函数，后面会讲到，这里首先看 newproc 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">// 创建 G 运行 fn , 参数大小为 siz 。把 G 放到等待队列。编译器会将 go 语句转化为该调用。</span></span><br><span class="line"><span class="comment">// 这时不能将栈进行分段，因为它假设了参数在 &amp;fn 之后顺序有效；如果 stack 进行了分段则他们不无法被拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line"><span class="comment">//  add 是一个指针运算，跳过函数指针，把栈上的参数起始地址找到，见 runtime2.go 中的 funcval 类型</span></span><br><span class="line">argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 获取调用方 PC 寄存器值</span></span><br><span class="line">pc := getcallerpc()</span><br><span class="line"><span class="comment">// 用 g0 系统栈创建 goroutine 对象。传递的参数包括 fn 函数入口地址, argp 参数起始地址, siz 参数长度, gp(g0)，调用方 pc(goroutine)</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个运行 fn 的新 g，具有 narg 字节大小的参数，从 argp 开始。callerps 是 go 语句的起始地址。新创建的 g 会被放入 g 的队列中等待运行。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 因为是在系统栈运行所以此时的 g 为 g0</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 p</span></span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line"><span class="comment">// 从 g 空闲列表中，根据 p 获得一个新的 g</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化阶段，gfget 是不可能找到 g 的，也可能运行中本来就已经耗尽了</span></span><br><span class="line"><span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个拥有 _StackMin (2kb) 大小的栈的 g</span></span><br><span class="line">newg = malg(_StackMin)</span><br><span class="line"><span class="comment">// 将新创建的 g 从 _Gidle 更新为 _Gdead 状态</span></span><br><span class="line">casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line"><span class="comment">// 将 Gdead 状态的 g 添加到 allg，这样 GC 不会扫描未初始化的栈</span></span><br><span class="line">allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算运行空间大小，与 spAlign 对齐</span></span><br><span class="line">totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line"><span class="comment">// 确定 sp 和参数入栈位置</span></span><br><span class="line">sp := newg.stack.hi - totalSize</span><br><span class="line">spArg := sp</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理参数，当有参数时，将参数拷贝到 goroutine 的执行栈中</span></span><br><span class="line"><span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 从 argp 参数开始的位置，复制 narg 个字节到 spArg（参数拷贝）</span></span><br><span class="line">memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理、创建并初始化的 g 的运行现场</span></span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line"><span class="comment">// 设置 newg 的 sched 成员，调度器需要依靠这些字段才能把 goroutine 调度到 CPU 上运行。</span></span><br><span class="line">newg.sched.sp = sp <span class="comment">// newg 的栈顶</span></span><br><span class="line">newg.stktopsp = sp</span><br><span class="line"><span class="comment">// newg.sched.pc 表示当 newg 被调度起来运行时从这个地址开始执行指令，也说是 goexit 函数的第二条指令。</span></span><br><span class="line"><span class="comment">// 把 pc 设置成了 goexit 这个函数偏移 1 （ amd64 中 sys.PCQuantum 等于 1 ）的位置。</span></span><br><span class="line"><span class="comment">// 这里为什么 goexit 是第二条指令？ 需要看 gostartcallfn 函数。</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function // +PCQuantum 从而前一个指令还在相同的函数内</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line"><span class="comment">// gostartcallfn 会获取 fn 的函数地址，然后调用 gostartcall</span></span><br><span class="line"><span class="comment">// gostartcall函数的主要作用有两个：</span></span><br><span class="line"><span class="comment">// 调整 newg 的栈空间，把 goexit 函数的第二条指令的地址入栈，伪造成 goexit 函数调用了 fn ，从而使 fn 执行完成后执行 ret 指令时返回到 goexit 继续执行完成最后的清理工作；</span></span><br><span class="line"><span class="comment">// 重新设置 newg.buf.pc 为需要执行的函数的地址，即 fn ，初始化时为 runtime.main 函数的地址。</span></span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 g 的基本状态</span></span><br><span class="line">newg.gopc = callerpc                     <span class="comment">//主要用于 traceback</span></span><br><span class="line">newg.ancestors = saveAncestors(callergp) <span class="comment">// 调试相关，追踪调用方</span></span><br><span class="line"><span class="comment">// 设置 newg 的 startpc 为 fn.fn ，该成员主要用于函数调用栈的 traceback 和栈收缩</span></span><br><span class="line"><span class="comment">// newg 真正从哪里开始执行并不依赖于这个成员，而是 newg.sched.pc</span></span><br><span class="line">newg.startpc = fn.fn</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 g 更换为 _Grunnable 状态</span></span><br><span class="line">casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将这里新创建的 g 放入 p 的本地队列，如果已满，则放入全局队列，true 表示放入执行队列的下一个 (_p_.runnext)，false 表示放入队尾</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/stack.go</span></span><br><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.</span></span><br><span class="line"><span class="comment">// 调整 Gobuf ，就好像它执行了对 fn 的调用了一样，然后立即进行 gosave 。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">fn = unsafe.Pointer(fv.fn) <span class="comment">// fn: gorotine 的入口地址，初始化时对应的是 runtime.main ，其它对应各自的 gorotine 的入口地址。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">&#125;</span><br><span class="line">gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/sys_x86.go</span></span><br><span class="line"><span class="comment">// adjust Gobuf as if it executed a call to fn with context ctxt</span></span><br><span class="line"><span class="comment">// and then did an immediate gosave.、</span></span><br><span class="line"><span class="comment">// 调整 Gobuf ，就好像它使用上下文 ctxt 执行了对 fn 的调用，然后立即执行了 gosave 一样。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// newg 的栈顶，目前 newg 栈上只有 fn 函数的参数， sp 指向的是 fn 的第一参数</span></span><br><span class="line">sp := buf.sp</span><br><span class="line"><span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">sp -= sys.PtrSize</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">sp -= sys.PtrSize <span class="comment">// 栈空间是高地址向低地址增长，为返回地址预留空间</span></span><br><span class="line"><span class="comment">// 这里在伪装 fn 是被 goexit 函数调用的，使得 fn 执行完后返回到 goexit 继续执行，从而完成清理工作</span></span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc <span class="comment">// 在栈上放入 goexit+1 的地址</span></span><br><span class="line">buf.sp = sp                              <span class="comment">// 新设置 newg 的栈顶寄存器</span></span><br><span class="line"><span class="comment">// 这里才真正让 newg 的 pc 寄存器指向 fn 函数，等到 newg 被调度起来运行时，调度器会把 buf.pc 放入 cpu 的 IP 寄存器，</span></span><br><span class="line"><span class="comment">// 从而使 newg 得以在 cpu 上真正的运行起来。</span></span><br><span class="line">buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面我们可以看到， newproc 最终在 g0 上调用 newproc1 ，然后 <code>newg := gfget(_p_)</code> 获取一个 g ，如果获取不到则通过 malg （malg会设置其栈字段）新建一个 g （这个当然是新建），为其分配 2KB 大小的栈，设置其状态为 <code>_Gdead</code> 然后添加到全局变量 allgs 中。</p><p>&emsp;&emsp;接着会拷贝参数到 newg 的栈上，然后初始化 newg.sched ，其中最重要的莫过于 sp , pc 。注意 newg.sched.pc 先设置的是 goexit + 1 （也说是 goexit 函数的第二条指令。），然后调用了 gostartcallfn , gostartcallfn 会获取 fn 的函数地址，然后调用 gostartcall 。</p><p>&emsp;&emsp;gostartcall函数的主要作用有两个：</p><ol><li>调整 newg 的栈空间，把 goexit 函数的第二条指令的地址入栈，伪造成 goexit 函数调用了 fn ，从而使 fn 执行完成后执行 ret 指令时返回到 goexit 继续执行完成最后的清理工作；</li><li>重新设置 newg.buf.pc 为需要执行的函数的地址，即 fn ，初始化时为 runtime.main 函数的地址。</li></ol><p>&emsp;&emsp;然后设置 newg 的一些基本信息，设置为 <code>_Grunnable</code> 状态，然后设置为下一个待运行的。因为初始化的时候队列为空，不可能放到全局队列，p.runnext 也还没有，这里就设置到 p.runnext ，就等待调度了，用户确定不了什么时候开始执行。</p><h3 id="开始调度循环"><a href="#开始调度循环" class="headerlink" title="开始调度循环"></a>开始调度循环</h3><p>&emsp;&emsp;前面创建了一个 goroutine，设置好了 sched 成员的 sp 和 pc 字段，并且将其添加到了 p0 的本地可运行队列，还没有绑定 m ，坐等调度器的调度。我们继续看 runtime·rt0_go 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// start this M</span></span><br><span class="line">CALLruntime·mstart(SB)<span class="comment">// 启动调度程序，调度到刚刚创建的 goroutine 执行，在 proc.go 函数原型： func mstart()</span></span><br><span class="line"></span><br><span class="line">CALLruntime·abort(SB)<span class="comment">// mstart should never return //  mstart 永远不会返回</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的变量 mainPC 为 runtime.main 函数的地址，该变量为 read only</span></span><br><span class="line">DATAruntime·mainPC+<span class="number">0</span>(SB)/<span class="number">8</span>,$runtime·main(SB)</span><br><span class="line">GLOBLruntime·mainPC(SB),RODATA,$<span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面终于调用到 runtime·mstart 核心代码了，开启调度器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// Called to start an M.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must not split the stack because we may not even have stack</span></span><br><span class="line"><span class="comment">// bounds set up yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run during STW (because it doesn't have a P yet), so write</span></span><br><span class="line"><span class="comment">// barriers are not allowed.</span></span><br><span class="line"><span class="comment">// 启动 M ， M 的入口函数</span></span><br><span class="line"><span class="comment">// 该函数不允许分段栈，因为我们甚至还没有设置栈的边界。它可能会在 STW 阶段运行（因为它还没有 P），所以 write barrier 也是不允许的</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定执行栈的边界。通过检查 g 执行占的边界来确定是否为系统栈</span></span><br><span class="line">osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> osStack &#123;</span><br><span class="line"><span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line"><span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line"><span class="comment">// minit may update the stack bounds.</span></span><br><span class="line"><span class="comment">// 根据系统栈初始化执行栈的边界。cgo 可能会离开 stack.hi 。minit 可能会更新栈的边界</span></span><br><span class="line">size := _g_.stack.hi</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">&#125;</span><br><span class="line">_g_.stack.hi = <span class="keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initialize stack guards so that we can start calling</span></span><br><span class="line"><span class="comment">// both Go and C functions with stack growth prologues.</span></span><br><span class="line"><span class="comment">// 初始化堆栈守卫，以便我们可以使用堆栈增长 prologue (序言) 开始调用Go和C函数。</span></span><br><span class="line">_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">_g_.stackguard1 = _g_.stackguard0</span><br><span class="line"><span class="comment">// 启动 M</span></span><br><span class="line">mstart1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit this thread.</span></span><br><span class="line"><span class="comment">// 退出线程</span></span><br><span class="line"><span class="keyword">if</span> GOOS == <span class="string">"windows"</span> || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"plan9"</span> || GOOS == <span class="string">"darwin"</span> || GOOS == <span class="string">"aix"</span> &#123;</span><br><span class="line"><span class="comment">// Window, Solaris, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line"><span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line"><span class="comment">// so the logic above hasn't set osStack yet.</span></span><br><span class="line"><span class="comment">// Window，Solaris，Darwin，AIX和Plan 9始终对栈进行系统分配，但将其放在mstart之前的_g_.stack中，因此上述逻辑尚未设置osStack。</span></span><br><span class="line">osStack = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出线程</span></span><br><span class="line">mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mstart 主要获取当前的 g ，然后设置 stackguard0 ， stackguard1 ，然后直接调用 mstart1 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前执行的 g 是不是 g0</span></span><br><span class="line"><span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">throw(<span class="string">"bad runtime·mstart"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the caller for use as the top of stack in mcall and</span></span><br><span class="line"><span class="comment">// for terminating the thread.</span></span><br><span class="line"><span class="comment">// We're never coming back to mstart1 after we call schedule,</span></span><br><span class="line"><span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line"><span class="comment">// 这里会记录前一个调用者的状态， 包含 PC , SP 以及其他信息。这份记录会当作最初栈 (top stack)，给之后的 mcall 调用，也用来结束那个线程。</span></span><br><span class="line"><span class="comment">// 接下來在 mstart1 调用到 schedule 之后就再也不会回到这个地方了，所以其他调用可以重用当前帧。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助编译器的帮助获取 PC 和 SP , 然后在 save 中更新当前 G 的 sched (type gobuf) 的一些成员， 保存调用者的 pc 和 sp ，让日后其他执行者执行 gogo 函数的时候使用。</span></span><br><span class="line">save(getcallerpc(), getcallersp())</span><br><span class="line">asminit() <span class="comment">// 初始化汇编，但是 amd64 架构下不需要执行任何代码就立刻返回，其他像是 arm、386 才有一些需在这里设定一些 CPU 相关的內容。</span></span><br><span class="line">minit()   <span class="comment">// 初始化m 包括信号栈和信号掩码，procid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line"><span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line"><span class="comment">// 设置信号 handler ；在 minit 之后，因为 minit 可以准备处理信号的的线程</span></span><br><span class="line"><span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line"><span class="comment">// 在当前的 goroutine 的所属执行者是 m0 的情況下进入 mstartm0 函数，正式启动在此之前的 signal 处理设定，其中最关键的是 initsig 函数。</span></span><br><span class="line">mstartm0()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行启动函数</span></span><br><span class="line"><span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 m 并非 m0，则要求绑定 p</span></span><br><span class="line"><span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 彻底准备好，开始调度，永不返回</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mstartm0 implements part of mstart1 that only runs on the m0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed here because we know the GC can't be</span></span><br><span class="line"><span class="comment">// running yet, so they'll be no-ops.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mstartm0 实现了一部分 mstart1，只运行在 m0 上。允许 write barrier，因为我们知道 GC 此时还不能运行，因此他们没有操作。</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstartm0</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an extra M for callbacks on threads not created by Go.</span></span><br><span class="line"><span class="comment">// An extra M is also needed on Windows for callbacks created by</span></span><br><span class="line"><span class="comment">// syscall.NewCallback. See issue #6751 for details.</span></span><br><span class="line"><span class="comment">// 创建一个额外的 M 处理 non-Go 线程（cgo 调用中产生的线程）的回调，并且只创建一个。windows 上也需要额外 M 来处理 syscall.NewCallback 产生的回调，见 issue #6751</span></span><br><span class="line"><span class="keyword">if</span> (iscgo || GOOS == <span class="string">"windows"</span>) &amp;&amp; !cgoHasExtraM &#123;</span><br><span class="line">cgoHasExtraM = <span class="literal">true</span></span><br><span class="line">newextram()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化信号。</span></span><br><span class="line">initsig(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save updates getg().sched to refer to pc and sp so that a following</span></span><br><span class="line"><span class="comment">// gogo will restore pc and sp.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// save must not have write barriers because invoking a write barrier</span></span><br><span class="line"><span class="comment">// can clobber getg().sched.</span></span><br><span class="line"><span class="comment">// save 更新了 getg().sched 的 pc 和 sp 的指向，并允许 gogo 能够恢复到 pc 和 sp 。 save 不允许 write barrier， 因为会破坏 getg().sched 。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(pc, sp <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">_g_.sched.pc = pc</span><br><span class="line">_g_.sched.sp = sp</span><br><span class="line">_g_.sched.lr = <span class="number">0</span></span><br><span class="line">_g_.sched.ret = <span class="number">0</span></span><br><span class="line">_g_.sched.g = guintptr(unsafe.Pointer(_g_))</span><br><span class="line"><span class="comment">// We need to ensure ctxt is zero, but can't have a write</span></span><br><span class="line"><span class="comment">// barrier here. However, it should always already be zero.</span></span><br><span class="line"><span class="comment">// Assert that.</span></span><br><span class="line"><span class="comment">// 我们必须确保 ctxt 为零，但这里不允许 write barrier。 所以这里只是做一个断言。</span></span><br><span class="line"><span class="keyword">if</span> _g_.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">badctxt()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先调用 save 函数来保存 g0 的调度信息。save 函数执行完成后，继续其它跟 m 相关的一些初始化，然后调用调度系统的核心函数 schedule() 完成 goroutine 的调度，每次调度 goroutine 都是从 schedule 函数开始的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">// 调度器的一轮：找到 runnable goroutine 并进行执行且永不返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度的时候， m 不能持有 locks</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 M 锁定了某个 G ，那么应该交出P，进入休眠。等待某个 M 调度拿到 lockedg ，然后唤醒 lockedg 的 M</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">stoplockedm()                       <span class="comment">// 停止当前正在执行锁住的 g 的 m 的执行，直到 g 重新变为 runnable ， 被唤醒 。 返回时关联了 P</span></span><br><span class="line">execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line"><span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line"><span class="comment">// 我们不应该调度一个正在执行 cgo 调用的 g ， 因为 cgo 在使用当前 m 的 g0 栈</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line"><span class="comment">// 如果当前 GC 需要（STW), 则调用 gcstopm 休眠当前的 M</span></span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">gcstopm()</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有安全点函数， 则执行</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">runSafePointFn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gp *g</span><br><span class="line"><span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// 如果启动 trace 或等待 trace reader</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line"><span class="comment">// 有 trace reader 需要被唤醒则标记 _Grunnable</span></span><br><span class="line">gp = traceReader()</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  如果当前 GC 正在标记阶段，允许置黑对象，则查找有没有待运行的 GC Worker, GC Worker 也是一个 G</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明不在 gc</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line"><span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line"><span class="comment">// by constantly respawning each other.</span></span><br><span class="line"><span class="comment">// 每调度 61 次，就检查一次全局队列，保证公平性。否则两个 goroutine 可以通过不断地互相 respawn（重生） 一直占领本地的 runqueue</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 从p的本地队列中获取</span></span><br><span class="line">gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line"><span class="comment">// 本地有 g ，则 m 不应该在 spinning 状态</span></span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 想尽办法找到可运行的 G ，找不到就不用返回了</span></span><br><span class="line">gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候肯定取到 g 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line"><span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line"><span class="comment">// start a new spinning M.</span></span><br><span class="line"><span class="comment">// 该线程将运行 goroutine ，并且不再 spinning ，因此，如果将其标记为 spinning ，则需要立即将其重置并可能启动新的 spinning M 。</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line"><span class="comment">// 如果 m 是 spinning 状态，则：</span></span><br><span class="line"><span class="comment">//  1. 从 spinning -&gt; non-spinning</span></span><br><span class="line"><span class="comment">//  2. 在没有 spinning 的 m 的情况下，再多创建一个新的 spinning m</span></span><br><span class="line">resetspinning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果禁用用户地 G 调度，并且 gp 不能够调度， 表示 gp 是用户 G ，不是系统 G</span></span><br><span class="line"><span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line"><span class="comment">// Scheduling of this goroutine is disabled. Put it on</span></span><br><span class="line"><span class="comment">// the list of pending runnable goroutines for when we</span></span><br><span class="line"><span class="comment">// re-enable user scheduling and look again.</span></span><br><span class="line"><span class="comment">// 禁用此 goroutine 的调度。 当我们重新启用用户调度并再次查看时，将其放在待处理的可运行 goroutine 列表中。</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 锁住后重新检测</span></span><br><span class="line"><span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line"><span class="comment">// Something re-enabled scheduling while we</span></span><br><span class="line"><span class="comment">// were acquiring the lock.</span></span><br><span class="line"><span class="comment">// 当我们之前正在获取锁的时候，可能有什么重新启动了调度， 也就是锁住之前，可能哪里重新启动了用户 g 调度。</span></span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 加入到禁用掉的等待的可运行的 G 队尾</span></span><br><span class="line">sched.disable.runnable.pushBack(gp)</span><br><span class="line">sched.disable.n++</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 gp 锁定了 m</span></span><br><span class="line"><span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line"><span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line"><span class="comment">//  让出 gp 给其锁定的 m ，然后阻塞等待新的 p</span></span><br><span class="line">startlockedm(gp) <span class="comment">// 调度锁定的 m 来运行锁定的 gp</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行</span></span><br><span class="line">execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P's, get g from global queue, poll network.</span></span><br><span class="line"><span class="comment">// 寻找一个可运行的 goroutine 来执行。尝试从其他的 P 偷取、从本地或者全局队列中获取、pollnet 。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line"><span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line"><span class="comment">// an M.</span></span><br><span class="line"><span class="comment">// 这里的条件与 handoffp 中的条件必须一致：如果 findrunnable 将返回 G 来运行，handoffp 必须启动 M 。</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">gcstopm() <span class="comment">// 如果在 gc，则 park 当前 m，直到被 unpark 后回到 top</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">runSafePointFn() <span class="comment">// 如果需要执行安全点函数，则执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line"><span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  cgo 调用被终止，继续进入</span></span><br><span class="line"><span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// local runq</span></span><br><span class="line"><span class="comment">// 取本地队列 local runq，如果已经拿到，立刻返回</span></span><br><span class="line"><span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gp, inheritTime</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global runq</span></span><br><span class="line"><span class="comment">// 全局队列 global runq，如果已经拿到，立刻返回</span></span><br><span class="line"><span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Poll network.</span></span><br><span class="line"><span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line"><span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line"><span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line"><span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line"><span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line"><span class="comment">// anyway.</span></span><br><span class="line"><span class="comment">// Poll 网络，优先级比从其他 P 中偷要高。在我们尝试去其他 P 偷之前，这个 netpoll 只是一个优化。如果没有 waiter 或 netpoll 中的线程已被阻塞，</span></span><br><span class="line"><span class="comment">// 则可以安全地跳过它。如果有任何类型的逻辑竞争与被阻塞的线程（例如它已经从 netpoll 返回，但尚未设置 lastpoll），该线程无论如何都将阻塞 netpoll 。</span></span><br><span class="line"><span class="comment">//  netpoll 已经初始化了，并且没有在等待 netpoll 的 g ，并且 sched.lastpoll != 0 ， 下面候可能将 sched.lastpoll 设置为 0 ，然后阻塞调用</span></span><br><span class="line"><span class="comment">//  netpoll(true)，返回后才设置 lastpoll ， 如果 sched.lastpoll == 0 的话，则表示 netpoll 还在阻塞， 这时候是 netpool 没有就绪 g 的。</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 轮询就绪的网络链接，查找 runnable G</span></span><br><span class="line"><span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">gp := list.pop()                      <span class="comment">// 获取一个</span></span><br><span class="line">injectglist(&amp;list)                    <span class="comment">// 将 netpool 中剩余的 runnable g 列表插入到调度器中</span></span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable) <span class="comment">// 设置状态为 _Grunnable</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回从 netpoll 中窃取到的 g</span></span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Steal work from other P's.</span></span><br><span class="line"><span class="comment">// 从其他 P 中窃取 work</span></span><br><span class="line">procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class="line"><span class="comment">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class="line"><span class="comment">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class="line"><span class="comment">//  GOMAXPROCS=1 或除我们之外的每个 P 都空闲。 通过返回 syscall/cgocall，network 或 timers，可以找到新 P。</span></span><br><span class="line"><span class="comment">// 两者都不会提交到本地运行队列，因此在窃取方面毫无意义。</span></span><br><span class="line"><span class="keyword">goto</span> stop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class="line"><span class="comment">// This is necessary to prevent excessive CPU consumption</span></span><br><span class="line"><span class="comment">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line"><span class="comment">//  如果 spinning 状态下 m 的数量 &gt;= busy 状态下 p 的数量，直接进入阻塞。该步骤是有必要的，它用于当 GOMAXPROCS&gt;&gt;1 时</span></span><br><span class="line"><span class="comment">// 但程序的并行机制很慢时昂贵的 CPU 消耗。</span></span><br><span class="line"><span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line"><span class="keyword">goto</span> stop</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 m 是 non-spinning 状态，切换为 spinning</span></span><br><span class="line"><span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 随机窃取</span></span><br><span class="line"><span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> top <span class="comment">// 已经进入了 GC? 回到 top ，park 当前的 m</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果偷了3次都偷不到，连 p.runnext (是当前G准备好的可运行G) 都窃取</span></span><br><span class="line">stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line"><span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 窃取到了就返回</span></span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line"><span class="comment">// We have nothing to do. If we're in the GC mark phase, can</span></span><br><span class="line"><span class="comment">// safely scan and blacken objects, and have work to do, run</span></span><br><span class="line"><span class="comment">// idle-time marking rather than give up the P.</span></span><br><span class="line"><span class="comment">// 没有任何 work 可做。如果我们在 GC mark 阶段，则可以安全的扫描并 blacken 对象，然后便有 work 可做，运行 idle-time 标记而非直接放弃当前的 P。</span></span><br><span class="line"><span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wasm only:</span></span><br><span class="line"><span class="comment">// If a callback returned and no other goroutine is awake,</span></span><br><span class="line"><span class="comment">// then pause execution until a callback was triggered.</span></span><br><span class="line"><span class="comment">// 仅限于 wasm 。如果一个回调返回后没有其他 goroutine 是苏醒的。则暂停执行直到回调被触发。</span></span><br><span class="line"><span class="keyword">if</span> beforeIdle() &#123;</span><br><span class="line"><span class="comment">// At least one goroutine got woken.</span></span><br><span class="line"><span class="comment">// 至少一个 goroutine 被唤醒</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span><br><span class="line"><span class="comment">// which can change underfoot once we no longer block</span></span><br><span class="line"><span class="comment">// safe-points. We don't need to snapshot the contents because</span></span><br><span class="line"><span class="comment">// everything up to cap(allp) is immutable.</span></span><br><span class="line"><span class="comment">// 放弃当前的 P 之前，对 allp 做一个快照。一旦我们不再阻塞在 safe-point 时候，可以立刻在下面进行修改。</span></span><br><span class="line"><span class="comment">// 我们不需要对内容进行快照，因为 cap(allp) 的所有内容都是不可变的。</span></span><br><span class="line">allpSnapshot := allp</span><br><span class="line"></span><br><span class="line"><span class="comment">// return P and block</span></span><br><span class="line"><span class="comment">// 准备归还 p，对调度器加锁</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// GC 或 运行安全点函数，则回到 top</span></span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局队列中又发现了 g</span></span><br><span class="line"><span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消关联 p 和当前 m</span></span><br><span class="line"><span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 p 放入 idle 链表</span></span><br><span class="line">pidleput(_p_)</span><br><span class="line"><span class="comment">// 完成归还，解锁</span></span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span><br><span class="line"><span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span><br><span class="line"><span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span><br><span class="line"><span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span><br><span class="line"><span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span><br><span class="line"><span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span><br><span class="line"><span class="comment">// to run the goroutine.</span></span><br><span class="line"><span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span><br><span class="line"><span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span><br><span class="line"><span class="comment">// than one starving goroutine). However, if after discovering new work</span></span><br><span class="line"><span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span><br><span class="line"><span class="comment">// the system is fully loaded so no spinning threads are required.</span></span><br><span class="line"><span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span><br><span class="line"><span class="comment">// 这里要非常小心: 线程从 spinning 到 non-spinning 状态的转换，可能与新 goroutine 的提交同时发生。 我们必须首先降低 nmspinning，</span></span><br><span class="line"><span class="comment">// 然后再次检查所有的 per-P 队列（并在期间伴随 #StoreLoad 内存屏障）。如果反过来，其他线程可以在我们检查了所有的队列、然后提交一个</span></span><br><span class="line"><span class="comment">//  goroutine、再降低 nmspinning ，进而导致无法 unpark 一个线程来运行那个 goroutine 了。</span></span><br><span class="line"><span class="comment">// 如果我们发现下面的新 work，我们需要恢复 m.spinning 作为重置的信号，以取消 park 新的工作线程（因为可能有多个饥饿的 goroutine）。</span></span><br><span class="line"><span class="comment">// 但是，如果在发现新 work 后我们也观察到没有空闲 P，可以暂停当前线程。因为系统已满载，因此不需要 spinning 线程。</span></span><br><span class="line"><span class="comment">// 请参考此文件顶部 "工作线程 parking/unparking" 的注释。</span></span><br><span class="line">wasSpinning := _g_.m.spinning <span class="comment">// 记录下之前的状态是否为 spinning</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line"><span class="comment">//  spinning 到 non-spinning 状态的转换，并递减 sched.nmspinning</span></span><br><span class="line">_g_.m.spinning = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check all runqueues once again</span></span><br><span class="line"><span class="comment">// 再次检查所有的 runqueue</span></span><br><span class="line"><span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line"><span class="comment">// 如果这时本地队列不空</span></span><br><span class="line"><span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line"><span class="comment">// 锁住调度，重新获取空闲的 p</span></span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">_p_ = pidleget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 如果能获取到空闲的 p</span></span><br><span class="line"><span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//  p 与当前 m 关联</span></span><br><span class="line">acquirep(_p_)</span><br><span class="line"><span class="comment">// 如果此前已经被切换为 spinning</span></span><br><span class="line"><span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line"><span class="comment">// 重新切换回 non-spinning</span></span><br><span class="line">_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时候是有 work 的，回到顶部重新找 g</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有空闲的 p，不需要重新找 g 了</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for idle-priority GC work again.</span></span><br><span class="line"><span class="comment">// 再次检查 idle-priority GC work 。和上面重新找 runqueue 的逻辑类似</span></span><br><span class="line"><span class="comment">//  gcMarkWorkAvailable 参数为 nil ，在这种情况下，它仅检查全局工作任务。</span></span><br><span class="line"><span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 获取空闲的 p</span></span><br><span class="line">_p_ = pidleget()</span><br><span class="line"><span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 获取到的 p 没有 background mask worker， 重新放回空闲 p 列表</span></span><br><span class="line">pidleput(_p_)</span><br><span class="line">_p_ = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 如果能获取到空闲的 p</span></span><br><span class="line"><span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//  p 与当前 m 关联</span></span><br><span class="line">acquirep(_p_)</span><br><span class="line"><span class="comment">// 如果此前已经被切换为 spinning</span></span><br><span class="line"><span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line"><span class="comment">// 重新切换回 non-spinning</span></span><br><span class="line">_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Go back to idle GC check.</span></span><br><span class="line"><span class="comment">// 这时候是有 work 的，回到顶部重新找 g</span></span><br><span class="line"><span class="keyword">goto</span> stop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll network</span></span><br><span class="line"><span class="comment">//  poll 网络。和上面重新找 runqueue 的逻辑类似</span></span><br><span class="line"><span class="comment">// netpoll 已经初始化了，并且没有在等待 netpoll 的 g ，并且 sched.lastpoll != 0 ，满足的话，会设置 sched.lastpoll = 0</span></span><br><span class="line"><span class="comment">//  atomic.Xchg64(&amp;sched.lastpoll, 0) 设置 sched.lastpoll = 0 ， 并返回原来的 sched.lastpoll</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">&#125;</span><br><span class="line">list := netpoll(<span class="literal">true</span>)                               <span class="comment">// block until new work is available // 阻塞直到有新的 work</span></span><br><span class="line">atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime())) <span class="comment">// 存储上一次 netpool 时间</span></span><br><span class="line"><span class="comment">//  netpoll 的 g list 不会空</span></span><br><span class="line"><span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 获取空闲的 p</span></span><br><span class="line">_p_ = pidleget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="comment">// 如果能获取到空闲的 p</span></span><br><span class="line"><span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//  p 与当前 m 关联</span></span><br><span class="line">acquirep(_p_)</span><br><span class="line">gp := list.pop()                      <span class="comment">// 获取一个</span></span><br><span class="line">injectglist(&amp;list)                    <span class="comment">// 将 netpool 中剩余的 runnable g 列表插入到调度器中</span></span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable) <span class="comment">// 设置状态为 _Grunnable</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回从 netpoll 中窃取到的 g</span></span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有获取到 p ，将 netpool 中获取到的 runnable g 列表插入到调度器中</span></span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确实找不到，park 当前的 m</span></span><br><span class="line">stopm()</span><br><span class="line"><span class="comment">//  m unpark 后继续找</span></span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;schedule 大致的执行流程是：</p><ol><li>如果当前 M 锁定了某个 G ，那么应该交出P，进入休眠。等待某个 M 调度拿到 lockedg ，然后唤醒 lockedg 的 M</li><li>如果当前 GC 需要（STW), 则调用 gcstopm 休眠当前的 M</li><li>如果有安全点函数， 则执行</li><li>找一个 g 来执行，找 g 的过程大致如下：<ol><li>如果当前 GC 正在标记阶段，允许置黑对象，则查找有没有待运行的 GC Worker, GC Worker 也是一个 G</li><li>调度器每调度 61 次的时候，都会尝试从全局队列里取出待运行的 goroutine 来运行，调用 globrunqget</li><li>调用 runqget 从 P 本地可运行队列先选出一个可运行的 goroutine 。</li><li>调用 findrunnable 尝试从其他的 P 偷取、从本地或者全局队列中获取、pollnet ，如果没找到会 pack 。如果没找到则调用 stopm 来 park m ，等到有任务的时候唤醒。</li></ol></li><li>调用  execute(gp, inheritTime) 开始执行 g 。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules gp to run on the current M.</span></span><br><span class="line"><span class="comment">// If inheritTime is true, gp inherits the remaining time in the</span></span><br><span class="line"><span class="comment">// current time slice. Otherwise, it starts a new time slice.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed because this is called immediately after</span></span><br><span class="line"><span class="comment">// acquiring a P in several places.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在当前 M 上调度 gp。 如果 inheritTime 为 true，则 gp 继承剩余的时间片。否则从一个新的时间片开始。 此函数永不返回。</span></span><br><span class="line"><span class="comment">// 该函数允许 write barrier 因为它是在 acquire P 之后的调用的。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 g 正式切换为 _Grunning 状态</span></span><br><span class="line">casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">gp.waitsince = <span class="number">0</span>                           <span class="comment">// 清除等待时间，现在开始执行了</span></span><br><span class="line">gp.preempt = <span class="literal">false</span>                         <span class="comment">// 关闭抢占</span></span><br><span class="line">gp.stackguard0 = gp.stack.lo + _StackGuard <span class="comment">// 设置栈边界检测</span></span><br><span class="line"><span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line"><span class="comment">// 如果不继承时间片，则开始新的</span></span><br><span class="line">_g_.m.p.ptr().schedtick++</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.curg = gp <span class="comment">// 设置当前循运行的 g</span></span><br><span class="line">gp.m = _g_.m    <span class="comment">// 设置运行的g的 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether the profiler needs to be turned on or off.</span></span><br><span class="line"><span class="comment">// 检查是否需要打开或关闭 cpu profiler 。</span></span><br><span class="line">hz := sched.profilehz</span><br><span class="line"><span class="keyword">if</span> _g_.m.profilehz != hz &#123;</span><br><span class="line">setThreadCPUProfiler(hz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trace</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line"><span class="comment">// GoSysExit has to happen when we have a P, but before GoStart.</span></span><br><span class="line"><span class="comment">// So we emit it here.</span></span><br><span class="line"><span class="keyword">if</span> gp.syscallsp != <span class="number">0</span> &amp;&amp; gp.sysblocktraced &#123;</span><br><span class="line">traceGoSysExit(gp.sysexitticks)</span><br><span class="line">&#125;</span><br><span class="line">traceGoStart()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从gobuf恢复状态，开始执行，gogo 实现在 asm_amd64.s 中</span></span><br><span class="line">gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;execute 这里首先将 p 的状态改为 <code>_Grunning</code> ，然年绑定 m 和 p ，让后调用 gogo(&amp;gp.sched) 来执行 g 。 gogo 是由汇编实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line"><span class="comment">// func gogo(buf *gobuf)</span></span><br><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line"><span class="comment">// 从 Gobuf 恢复状态; longjmp</span></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">MOVQbuf+<span class="number">0</span>(FP), BX<span class="comment">// gobuf //  BX = buf 运行现场</span></span><br><span class="line">MOVQgobuf_g(BX), DX<span class="comment">//  DX = buf.g</span></span><br><span class="line">MOVQ<span class="number">0</span>(DX), CX<span class="comment">// make sure g != nil // 确保 g != nil</span></span><br><span class="line">get_tls(CX)<span class="comment">//  CX = 当前 p</span></span><br><span class="line">MOVQDX, g(CX)<span class="comment">// 当前 g.g = buf.g</span></span><br><span class="line">MOVQgobuf_sp(BX), SP<span class="comment">// restore SP// SP = buf.sp</span></span><br><span class="line">MOVQgobuf_ret(BX), AX<span class="comment">// AX = buf.ret</span></span><br><span class="line">MOVQgobuf_ctxt(BX), DX<span class="comment">// DX = buf.ctxt</span></span><br><span class="line">MOVQgobuf_bp(BX), BP<span class="comment">// BP = buf.bp</span></span><br><span class="line">MOVQ$<span class="number">0</span>, gobuf_sp(BX)<span class="comment">// clear to help garbage collector // buf.sp = 0 清理数据有助于 GC</span></span><br><span class="line">MOVQ$<span class="number">0</span>, gobuf_ret(BX)<span class="comment">// buf.ret = 0</span></span><br><span class="line">MOVQ$<span class="number">0</span>, gobuf_ctxt(BX)<span class="comment">// buf.ctxt = 0</span></span><br><span class="line">MOVQ$<span class="number">0</span>, gobuf_bp(BX)<span class="comment">// buf.bp = 0</span></span><br><span class="line">MOVQgobuf_pc(BX), BX <span class="comment">// BX = buf.pc 获取 g 要执行的函数的入口地址</span></span><br><span class="line">JMPBX<span class="comment">// 跳转到对应的 buf.pc ，开始执行</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;gogo 中重点在 <code>MOVQ   gobuf_pc(BX), BX</code> ， 这个 pc 值是 gp 将要执行的指令，在初始化中，也就是 runtime.main 的第一条指令，然后 <code>JMP BX</code> 开始执行。</p><p>&emsp;&emsp;OK 到这里， runtime·main 终于动起来了，我们来看看 runtime.main 吧 ， 看看啥时候能运行行用户代码 <code>package main</code> 中的 main 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="comment">//  主 goroutine，也就是runtime·mainPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取当前的G, G为TLS(Thread Local Storage)</span></span><br><span class="line">g := getg()</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</span></span><br><span class="line"><span class="comment">// Using decimal instead of binary GB and MB because</span></span><br><span class="line"><span class="comment">// they look nicer in the stack overflow failure message.</span></span><br><span class="line"><span class="comment">// 执行栈的最大限制： 1GB on 64-bit， 250 MB on 32-bit。使用十进制而不是二进制GB和MB，因为它们在堆栈溢出失败消息中好看些。</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">maxstacksize = <span class="number">1000000000</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxstacksize = <span class="number">250000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line"><span class="comment">// 表示main goroutine启动了，接下来允许 newproc 启动新的 m</span></span><br><span class="line">mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 runtime.main 函数的 G 必须是绑定在 m0 上的</span></span><br><span class="line"><span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">throw(<span class="string">"runtime.main not on m0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  执行初始化运行时</span></span><br><span class="line">runtime_init() <span class="comment">// must be before defer //  defer 必须在此调用结束后才能使用</span></span><br><span class="line"><span class="keyword">if</span> nanotime() == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"nanotime returning zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 main_init，进行间接调用，因为链接器在设定运行时的时候不知道 main 包的地址</span></span><br><span class="line">fn := main_init <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">needUnlock = <span class="literal">false</span></span><br><span class="line">unlockOSThread()</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行用户 main 包中的 main 函数，处理为非间接调用，因为链接器在设定运行时不知道 main 包的地址</span></span><br><span class="line">fn = main_main <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出执行，返回退出状态码</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;runtime·main 限制了最大栈（近似 1GB on 64-bit， 250 MB on 32-bit），结合前面的，我们就知道了， go 动态栈的范围是 2KB 到 1GB/250MB 。然后 <code>fn = main_main ; fn()</code> 终于执行到用户代码了，真不容易啊！然后直接调用 exit 结束进程了。注意这里是 main goroutine !</p><p>&emsp;&emsp;咦，咋就这么结束了？还有其它的 goroutine 呢？ 都不管了？</p><p>&emsp;&emsp;我们回忆以下，main goroutine 的入口函数是 runtime·mainPC 也就是 runtime.main 函数，通过 <code>schedule() -&gt; execute() -&gt; gogo()</code> 中 gogo 函数用汇编跳转的，后面没有指令了，返回到哪里？。另外 runtime.main 会等用户代码执行完返回，我们用户代码返回了，这里 exit 也合情合理。 </p><p>&emsp;&emsp;之前有分析过， newproc1 的 <code>newg.sched.pc = funcPC(goexit) + sys.PCQuantum</code> 的时候有伪造 goexit 函数调用 goroutine 的入口函数，上面说分析了 main goroutine 直接退出了， 非 main goroutine 执行完成后就会返回到 goexit 继续执行， 我们来看看非 main goroutine的后续处理 goexit 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_amd64.s</span></span><br><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line"><span class="comment">// 在 goroutine 上运行的最顶层函数将返回goexit + PCQuantum。</span></span><br><span class="line"><span class="comment">// goroutine 执行完成后返回后执行： CALLruntime·goexit1(SB)</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">BYTE$<span class="number">0x90</span><span class="comment">// NOP</span></span><br><span class="line">CALLruntime·goexit1(SB)<span class="comment">// does not return  // 永不返回</span></span><br><span class="line"><span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">BYTE$<span class="number">0x90</span><span class="comment">// NOP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="comment">// 完成当前 goroutine 的执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racegoend()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoEnd()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始收尾工作</span></span><br><span class="line">mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之前分析过， gostartcallfn 是把 goexit 函数的第二条指令的地址入栈，伪造成 goexit 函数调用了 fn ，也就是这里的 runtime·goexit1 函数，goexit1 调用到 mcall(goexit0) 了， mcall 切换到 g0 然后执行 goexit0 ，这里再继续可能看 goexit0 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="comment">//  goexit 继续在 g0 上执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换当前的 g 为 _Gdead</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line"><span class="comment">// 如果是系统 g ， 更新统计信息</span></span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清理</span></span><br><span class="line">gp.m = <span class="literal">nil</span></span><br><span class="line">locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">gp.lockedm = <span class="number">0</span></span><br><span class="line">_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">gp.paniconfault = <span class="literal">false</span></span><br><span class="line">gp._defer = <span class="literal">nil</span> <span class="comment">// should be true already but just in case. // 应该已经为 true，但以防万一</span></span><br><span class="line">gp._panic = <span class="literal">nil</span> <span class="comment">// non-nil for Goexit during panic. points at stack-allocated data. //  Goexit 中 panic 则不为 nil， 指向栈分配的数据</span></span><br><span class="line">gp.writebuf = <span class="literal">nil</span></span><br><span class="line">gp.waitreason = <span class="number">0</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gp.labels = <span class="literal">nil</span></span><br><span class="line">gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Flush assist credit to the global pool. This gives</span></span><br><span class="line"><span class="comment">// better information to pacing if the application is</span></span><br><span class="line"><span class="comment">// rapidly creating an exiting goroutines.</span></span><br><span class="line"><span class="comment">// 刷新 assist credit 到全局池。如果政协在快速创建已存在的 goroutine，这可以为 pacing 提供更好的信息。</span></span><br><span class="line">scanCredit := <span class="keyword">int64</span>(gcController.assistWorkPerByte * <span class="keyword">float64</span>(gp.gcAssistBytes))</span><br><span class="line">atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that gp's stack scan is now "valid" because it has no</span></span><br><span class="line"><span class="comment">// stack.</span></span><br><span class="line"><span class="comment">// 请注意， gp 的栈扫描现在 “有效” ，因为它没有栈。</span></span><br><span class="line">gp.gcscanvalid = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 移除 m 与当前 goroutine m-&gt;curg 之间的关联</span></span><br><span class="line">dropg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> GOARCH == <span class="string">"wasm"</span> &#123; <span class="comment">// no threads yet on wasm //  wasm 目前还没有线程支持</span></span><br><span class="line">gfput(_g_.m.p.ptr(), gp) <span class="comment">// 将 g 放进 gfree 链表中等待复用</span></span><br><span class="line">schedule()               <span class="comment">// never returns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  lockOSThread/unlockOSThread 调用不匹配</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"invalid m-&gt;lockedInt = "</span>, _g_.m.lockedInt, <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"internal lockOSThread error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gfput(_g_.m.p.ptr(), gp) <span class="comment">// 将 g 放进 gfree 链表中等待复用</span></span><br><span class="line"><span class="keyword">if</span> locked &#123;</span><br><span class="line"><span class="comment">// The goroutine may have locked this thread because</span></span><br><span class="line"><span class="comment">// it put it in an unusual kernel state. Kill it</span></span><br><span class="line"><span class="comment">// rather than returning it to the thread pool.</span></span><br><span class="line"><span class="comment">// 该 goroutine 可能在当前线程上锁住，因为它可能导致了不正常的内核状态。这时候 kill 该线程，而非将 m 放回到线程池。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return to mstart, which will release the P and exit</span></span><br><span class="line"><span class="comment">// the thread.</span></span><br><span class="line"><span class="comment">// 此举会返回到 mstart，从而释放当前的 P 并退出该线程</span></span><br><span class="line"><span class="keyword">if</span> GOOS != <span class="string">"plan9"</span> &#123; <span class="comment">// See golang.org/issue/22227.</span></span><br><span class="line"><span class="comment">//  mstart1 调用 save 保存的，这里恢复，则结束线程</span></span><br><span class="line">gogo(&amp;_g_.m.g0.sched)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clear lockedExt on plan9 since we may end up re-using</span></span><br><span class="line"><span class="comment">// this thread.</span></span><br><span class="line"><span class="comment">// 因为我们可能已重用此线程结束，在 plan9 上清除 lockedExt</span></span><br><span class="line">_g_.m.lockedExt = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次进行调度</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面我们可以看出，goexit0 主要是做一些清理工作，然后调用 schedule 继续调度。主要如下：</p><ol><li>将g 的状态从 <code>_Grunning</code> 变更为 <code>_Gdead</code></li><li>清零 g 的一些字段</li><li>调用 dropg 移除 m 与当前 goroutine m-&gt;curg 之间的关联</li><li>调用 gfput(<em>g</em>.m.p.ptr(), gp) 将 g 放进 gfree 链表中等待复用</li><li>调用 schedule 再次进行调度。</li></ol><p>&emsp;&emsp;至此，GO schedule 基本分析完了， Go Start The World !</p><p>&emsp;&emsp;那么我们这里总结一下：</p><p><img src="/2020/02/02/【golang源码分析】之GPM调度/GPM%E8%B0%83%E5%BA%A6.jpg" alt="GPM 调度"></p><p>&emsp;&emsp;如图所示，rt0_go 负责 Go 程序启动的所有初始化，中间进行了很多初始化工作，调用 mstart 之前，已经切换到了 g0 栈，图中不同色块表示使用不同的栈空间。</p><p>&emsp;&emsp;接着调用 gogo 函数，完成从 g0 栈到用户 goroutine 栈的切换，包括 main goroutine 和普通 goroutine。</p><p>&emsp;&emsp;之后，执行 main 函数或者用户自定义的 goroutine 任务。</p><p>&emsp;&emsp;执行完成后，main goroutine 直接调用 eixt(0) 退出，普通 goroutine 则调用 goexit -&gt; goexit1 -&gt; mcall，完成普通 goroutine 退出后的清理工作，然后切换到 g0 栈，调用 goexit0 函数，将普通 goroutine 添加到缓存池中，再调用 schedule 函数进行新一轮的调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schedule() -&gt; execute() -&gt; gogo() -&gt; goroutine 任务 -&gt; </span><br><span class="line">goexit() -&gt; goexit1() -&gt; mcall() -&gt; goexit0() -&gt; schedule()</span><br></pre></td></tr></table></figure><h3 id="GPM-状态转变"><a href="#GPM-状态转变" class="headerlink" title="GPM 状态转变"></a>GPM 状态转变</h3><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p><img src="/2020/02/02/【golang源码分析】之GPM调度/M%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg" alt="M状态转变"></p><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p><img src="/2020/02/02/【golang源码分析】之GPM调度/P%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg" alt="M状态转变"></p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p><img src="/2020/02/02/【golang源码分析】之GPM调度/G%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%98.jpg" alt="M状态转变"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;上一篇 &lt;a href&gt;【golang源码分析】之GPM概述&lt;/a&gt; ，我们介绍 GPM 的一些基础概念，这里将是重点，梳理 GMP 的调度流程。其实在 &lt;a href=&quot;https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/#more&quot;&gt;【golang源码分析】之启动追踪&lt;/a&gt; 中以及梳理了一下启动流程，涉及到的地方，这里会简要的过一下。&lt;/p&gt;&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;h3 id=&quot;程序的入口&quot;&gt;&lt;a href=&quot;#程序的入口&quot; class=&quot;headerlink&quot; title=&quot;程序的入口&quot;&gt;&lt;/a&gt;程序的入口&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// src/runtime/rt0_linux_amd64.s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  linux amd64 系统的启动函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TEXT _rt0_amd64_linux(SB),NOSPLIT,$&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JMP _rt0_amd64(SB) &lt;span class=&quot;comment&quot;&gt;// 跳转到_rt0_amd64函数， 在 asm_amd64.s 中。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// src/runtime/asm_amd64.s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TEXT _rt0_amd64(SB),NOSPLIT,$&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MOVQ    &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(SP), DI   &lt;span class=&quot;comment&quot;&gt;// argc     //  设置参数argc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LEAQ    &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(SP), SI   &lt;span class=&quot;comment&quot;&gt;// argv     //  设置参数argv&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JMP runtime·rt0_go(SB)          &lt;span class=&quot;comment&quot;&gt;//  跳转到runtime·rt0_go&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【golang源码分析】之GPM概述</title>
    <link href="https://veezhang.github.io/2020/01/29/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8BGPM%E6%A6%82%E8%BF%B0/"/>
    <id>https://veezhang.github.io/2020/01/29/【golang源码分析】之GPM概述/</id>
    <published>2020-01-29T09:43:31.000Z</published>
    <updated>2020-05-13T05:50:25.104Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我们知道 golang 原生支持并发，goroutine 就是其设计的核心。 goroutine 是用户态线程，也就是协程。这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，当然这不需要我们做什么工作，golang 已经帮我们处理了。在如今处处高并发的时代，很多库包括语言都有协程的影子。例如，腾讯的 <a href="https://github.com/tencent/libco" target="_blank" rel="noopener">libco</a> 是微信后台大规模使用的c/c++协程库；lua 也是有协程的。</p><a id="more"></a><h2 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h2><p>&emsp;&emsp;为什么要多此一举来设计协程呢？还要自己来负责调度。</p><ul><li>进程：分配完整独立的地址空间，拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程的切换只发生在内核态，由操作系统调度。</li><li>线程：和其它本进程的线程共享地址空间，拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程的切换一般也由操作系统调度(标准线程是的)。</li><li>协程：和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。</li></ul><p>&emsp;&emsp;进程切换分两步：</p><ol><li>切换页目录以使用新的地址空间</li><li>切换内核栈和硬件上下文</li></ol><p>&emsp;&emsp;对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。</p><p>&emsp;&emsp;切换的性能消耗：</p><ol><li><p>线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p></li><li><p>另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。</p></li></ol><p>&emsp;&emsp;进程和线程的切换主要依赖于时间片的控制，而协程的切换则主要依赖于自身，这样的好处是避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任。另外，协程一般拥有更小的创建，销毁和切换代价，以及更合理的内存分配，这也进一步提高性能。</p><h2 id="Goroutine-与线程"><a href="#Goroutine-与线程" class="headerlink" title="Goroutine 与线程"></a>Goroutine 与线程</h2><p>&emsp;&emsp;我们这里从<code>内存占用</code>，<code>创建销毁</code>和<code>切换代价</code>来对比下 Goroutine 与线程，来了解轻量的 Goroutine 。</p><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p>&emsp;&emsp;创建一个 goroutine 的栈内存消耗为 2KB(_StackMin = 2048)，实际运行过程中，如果栈空间不够用，会自动进行扩容，最大 1GB(maxstacksize = 1 &lt;&lt; 20) 。创建一个 thread 则默认需要消耗 8 MB (64bit系统) 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。线程的栈大小在可以 ulimit -s 查看或设置，也可以在 <code>/etc/security/limits.conf</code> 中配置，并且是固定的。而 goroutine 是动态栈，会根据需要动态地伸缩，小到 2KB 大到 1GB ，所以可以创建大量的 goroutine 。</p><h3 id="创建销毁"><a href="#创建销毁" class="headerlink" title="创建销毁"></a>创建销毁</h3><p>&emsp;&emsp;Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。</p><h3 id="切换代价"><a href="#切换代价" class="headerlink" title="切换代价"></a>切换代价</h3><p>线程切换大概在几微秒级别，协程切换大概在百 ns 级别。</p><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>&emsp;&emsp;线程切换过程:</p><ol><li>进入系统调用</li><li>调度器本身代码执行</li><li>线程上下文切换: PC, SP 等寄存器，栈，线程相关的一些局部变量，还涉及一些 cache miss 的情况；</li><li>退出系统调用</li></ol><p>&emsp;&emsp;当 threads 切换时需要保存的寄存器：</p><p>&emsp;&emsp;16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>&emsp;&emsp;goroutines 切换只需保存三个寄存器：</p><p>&emsp;&emsp;Program Counter, Stack Pointer and BP。以及一些其它的信息，在 <a href="#gobuf">gobuf 结构体中</a>。</p><h2 id="早期的-GM-模型"><a href="#早期的-GM-模型" class="headerlink" title="早期的 GM 模型"></a>早期的 GM 模型</h2><p>&emsp;&emsp;在 go 1.0 版本， 只有 GM ，而没有 P ， 只有一个全局可运行队列。</p><p><img src="/2020/01/29/【golang源码分析】之GPM概述/GM%E6%A8%A1%E5%9E%8B.jpg" alt="GM 模型"></p><p>&emsp;&emsp;存在一些缺陷：</p><ul><li>调度锁的粒度，一个全局的调度锁。创建、销毁、调度 G 都需要每个M获取锁，这就形成了激烈的锁竞争。</li><li>就绪的 G 被 M 取出执行的时候，并不一定是之前运行或创建 G 的那个 M ，这样线程局部性遭到破坏。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li><li>Go 内存分配类似 TCMalloc ，每个 M 都有 Thread Local Storage，每个 M 都有一些内存 cache ，只有运行的 G 的时候才需要这些 cache ，这样阻塞的 M 其实占用很大的内存。</li></ul><p>&emsp;&emsp;后来 Go 1.1 大神 Dmitry Vyokov 增加了 P 的概念，表示执行 G 所需的资源，当 M 和 P 绑定后才能执行 G ，比如 mcache ，本地队列等。</p><h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><p>&emsp;&emsp;主要的概念是：</p><ul><li>G: Goroutine，即我们在 Go 程序中使用 go 关键字创建的执行体。</li><li>M: Machine，或 worker thread，即传统意义上进程的线程；</li><li>P: processor，一种执行 Go 代码被要求资源。M 必须关联一个 P 才能执行 Go 代码，但它可以被阻塞或在一个系统调用中没有关联的 P。默认为机器核数，可通过环境变量 GOMAXPROCS 设置。</li></ul><p><img src="/2020/01/29/【golang源码分析】之GPM概述/GPM%E6%A8%A1%E5%9E%8B.jpg" alt="GPM 模型"></p><p>&emsp;&emsp;主要优化点：</p><ul><li>mcache 从 M 移动到 P 中。</li><li>每个 P 拥有本地运行队列，新建的 G 放到本地队列，只有当本地满了再批量放入到全局队列。获取的时候优先从本地队列取。</li><li>当本地队列没有 G 的时候，会从其它的地方窃取 (findrunnable() 函数)，比如：本地队列，全局队列， netpoll ， p.runnext 等。</li></ul><h2 id="主要结构体"><a href="#主要结构体" class="headerlink" title="主要结构体"></a>主要结构体</h2><p>&emsp;&emsp;这里涉及下主要的几个结构体。</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Stack parameters.</span></span><br><span class="line"><span class="comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span></span><br><span class="line"><span class="comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span></span><br><span class="line"><span class="comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span></span><br><span class="line"><span class="comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span></span><br><span class="line"><span class="comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span></span><br><span class="line"><span class="comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span></span><br><span class="line"><span class="comment">// Stack 参数</span></span><br><span class="line"><span class="comment">// stack 描述了实际的栈内存：[stack.lo, stack.hi)</span></span><br><span class="line"><span class="comment">// stackguard0 是对比 Go 栈增长的 prologue 的栈指针，如果 sp 寄存器比 stackguard0 小（由于栈往低地址方向增长），会触发栈拷贝和调度</span></span><br><span class="line"><span class="comment">// 通常情况下：stackguard0 = stack.lo + StackGuard，但被抢占时会变为 StackPreempt。</span></span><br><span class="line"><span class="comment">// stackguard1 是对比 C 栈增长的 prologue 的栈指针，当位于 g0 和 gsignal 栈上时，值为 stack.lo + StackGuard</span></span><br><span class="line"><span class="comment">// 在其他栈上值为 ~0 用于触发 morestackc (并 crash) 调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  prologue (序言) 函数是函数开头的几行代码，它们准备了堆栈和寄存器以供在函数内使用。 epilogue (尾声) 函数出现在函数的末尾，并将堆栈和寄存器恢复到调用函数之前的状态。</span></span><br><span class="line"><span class="comment">//  prologue/epilogue 参见：https://en.wikipedia.org/wiki/Function_prologue</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 编译器会在有栈溢出风险的函数开头加如 一些代码（也就是prologue），会比较 SP (栈寄存器,指向栈顶) 和 stackguard0，如果 SP 的值更小，说明当前 g 的栈要用完了，</span></span><br><span class="line"><span class="comment">// 有溢出风险，需要调用 morestack_noctxt 函数来扩栈，morestack_noctxt()-&gt;morestack()-&gt;newstack() ，newstack中会处理抢占(preempt)。参见 asm_amd64.s,stack.go</span></span><br><span class="line">stack       stack   <span class="comment">// offset known to runtime/cgo // 当前g使用的栈空间, 有lo和hi两个成员</span></span><br><span class="line">stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink //  stackguard0 = stack.lo + StackGuard ，检查栈空间是否足够的值, 低于这个值会扩张栈, 用于 GO 的 stack overlow的检测</span></span><br><span class="line">stackguard1 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink //  stackguard1 = stack.lo + StackGuard ，检查栈空间是否足够的值, 低于这个值会扩张栈, 用于 C 的 stack overlow的检测</span></span><br><span class="line"></span><br><span class="line">_panic         *_panic         <span class="comment">// innermost panic - offset known to liblink // 内部 panic ，偏移量用于 liblink</span></span><br><span class="line">_defer         *_defer         <span class="comment">// innermost defer // 内部 defer</span></span><br><span class="line">m              *m              <span class="comment">// current m; offset known to arm liblink // 当前 g 对应的 m ; 偏移量对 arm liblink 透明</span></span><br><span class="line">sched          gobuf           <span class="comment">// goroutine 的现场，g 的调度数据, 当 g 中断时会保存当前的 pc 和 sp 等值到这里, 恢复运行时会使用这里的值</span></span><br><span class="line">syscallsp      <span class="keyword">uintptr</span>         <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc // 如果 status==Gsyscall, 则 syscallsp = sched.sp 并在 GC 期间使用</span></span><br><span class="line">syscallpc      <span class="keyword">uintptr</span>         <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc // 如果 status==Gsyscall, 则 syscallpc = sched.pc 并在 GC 期间使用</span></span><br><span class="line">stktopsp       <span class="keyword">uintptr</span>         <span class="comment">// expected sp at top of stack, to check in traceback // 期望 sp 位于栈顶，用于回溯检查</span></span><br><span class="line">param          unsafe.Pointer  <span class="comment">// passed parameter on wakeup // wakeup 唤醒时候传递的参数</span></span><br><span class="line">atomicstatus   <span class="keyword">uint32</span>          <span class="comment">//  g 的当前状态，原子性</span></span><br><span class="line">stackLock      <span class="keyword">uint32</span>          <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus // sigprof/scang锁，将会归入到atomicstatus</span></span><br><span class="line">goid           <span class="keyword">int64</span>           <span class="comment">// goroutine ID</span></span><br><span class="line">schedlink      guintptr        <span class="comment">// 下一个 g , 当 g 在链表结构中会使用</span></span><br><span class="line">waitsince      <span class="keyword">int64</span>           <span class="comment">// approx time when the g become blocked // g 阻塞的时间</span></span><br><span class="line">waitreason     waitReason      <span class="comment">// if status==Gwaiting // 如果 status==Gwaiting，则记录等待的原因</span></span><br><span class="line">preempt        <span class="keyword">bool</span>            <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt // 抢占信号， g 是否被抢占中， stackguard0 = stackPreempt 的副本</span></span><br><span class="line">paniconfault   <span class="keyword">bool</span>            <span class="comment">// panic (instead of crash) on unexpected fault address // 发生 fault panic （不崩溃）的地址</span></span><br><span class="line">preemptscan    <span class="keyword">bool</span>            <span class="comment">// preempted g does scan for gc // 抢占式 g 会执行 GC scan</span></span><br><span class="line">gcscandone     <span class="keyword">bool</span>            <span class="comment">// g has scanned stack; protected by _Gscan bit in status // g 执行栈已经 scan 了；此此段受 _Gscan 位保护</span></span><br><span class="line">gcscanvalid    <span class="keyword">bool</span>            <span class="comment">// false at start of gc cycle, true if G has not run since last scan; <span class="doctag">TODO:</span> remove? // 在 gc 周期开始时为 false，如果自上次 scan 以来G没有运行，则为 true</span></span><br><span class="line">throwsplit     <span class="keyword">bool</span>            <span class="comment">// must not split stack // 必须不能进行栈分段</span></span><br><span class="line">raceignore     <span class="keyword">int8</span>            <span class="comment">// ignore race detection events // 忽略 race 检查事件</span></span><br><span class="line">sysblocktraced <span class="keyword">bool</span>            <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine //  StartTrace 已经出发了此 goroutine 的 EvGoInSyscall</span></span><br><span class="line">sysexitticks   <span class="keyword">int64</span>           <span class="comment">// cputicks when syscall has returned (for tracing) // 当 syscall 返回时的 cputicks（用于跟踪）</span></span><br><span class="line">traceseq       <span class="keyword">uint64</span>          <span class="comment">// trace event sequencer // 跟踪事件排序器</span></span><br><span class="line">tracelastp     puintptr        <span class="comment">// last P emitted an event for this goroutine // 最后一个为此 goroutine 触发事件的 P</span></span><br><span class="line">lockedm        muintptr        <span class="comment">//  g 是否要求要回到这个 M 执行, 有的时候 g 中断了恢复会要求使用原来的 M 执行</span></span><br><span class="line">sig            <span class="keyword">uint32</span>          <span class="comment">// 信号，参见 defs_linux_arm64.go : siginfo</span></span><br><span class="line">writebuf       []<span class="keyword">byte</span>          <span class="comment">// 写缓存</span></span><br><span class="line">sigcode0       <span class="keyword">uintptr</span>         <span class="comment">// 参见 siginfo</span></span><br><span class="line">sigcode1       <span class="keyword">uintptr</span>         <span class="comment">// 参见 siginfo</span></span><br><span class="line">sigpc          <span class="keyword">uintptr</span>         <span class="comment">// 产生信号时的PC</span></span><br><span class="line">gopc           <span class="keyword">uintptr</span>         <span class="comment">// pc of go statement that created this goroutine // 当前创建 goroutine go 语句的 pc 寄存器</span></span><br><span class="line">ancestors      *[]ancestorInfo <span class="comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors) // 创建此 goroutine 的 ancestor (祖先) goroutine 的信息(debug.tracebackancestors 调试用)</span></span><br><span class="line">startpc        <span class="keyword">uintptr</span>         <span class="comment">// pc of goroutine function // goroutine 函数的 pc 寄存器</span></span><br><span class="line">racectx        <span class="keyword">uintptr</span>         <span class="comment">// 竟态上下文</span></span><br><span class="line">waiting        *sudog          <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order // 如果 g 发生阻塞（且有有效的元素指针）sudog 会将当前 g 按锁住的顺序组织起来</span></span><br><span class="line">cgoCtxt        []<span class="keyword">uintptr</span>       <span class="comment">// cgo traceback context // cgo 回溯上下文</span></span><br><span class="line">labels         unsafe.Pointer  <span class="comment">// profiler labels // 分析器标签</span></span><br><span class="line">timer          *timer          <span class="comment">// cached timer for time.Sleep // 为 time.Sleep 缓存的计时器</span></span><br><span class="line">selectDone     <span class="keyword">uint32</span>          <span class="comment">// are we participating in a select and did someone win the race? // 我们是否正在参与 select 且某个 goroutine 胜出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-G GC state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcAssistBytes is this G's GC assist credit in terms of</span></span><br><span class="line"><span class="comment">// bytes allocated. If this is positive, then the G has credit</span></span><br><span class="line"><span class="comment">// to allocate gcAssistBytes bytes without assisting. If this</span></span><br><span class="line"><span class="comment">// is negative, then the G must correct this by performing</span></span><br><span class="line"><span class="comment">// scan work. We track this in bytes to make it fast to update</span></span><br><span class="line"><span class="comment">// and check for debt in the malloc hot path. The assist ratio</span></span><br><span class="line"><span class="comment">// determines how this corresponds to scan work debt.</span></span><br><span class="line"><span class="comment">//  gcAssistBytes 是该 G 在分配的字节数这一方面的的 GC 辅助 credit (信誉)</span></span><br><span class="line"><span class="comment">// 如果该值为正，则 G 已经存入了在没有 assisting 的情况下分配了 gcAssistBytes 字节，如果该值为负，则 G 必须在 scan work 中修正这个值</span></span><br><span class="line"><span class="comment">// 我们以字节为单位进行追踪，一遍快速更新并检查 malloc 热路径中分配的债务（分配的字节）。assist ratio 决定了它与 scan work 债务的对应关系</span></span><br><span class="line">gcAssistBytes <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">lock mutex <span class="comment">// 锁</span></span><br><span class="line"></span><br><span class="line">id          <span class="keyword">int32</span>      <span class="comment">// ID</span></span><br><span class="line">status      <span class="keyword">uint32</span>     <span class="comment">// one of pidle/prunning/... // 状态</span></span><br><span class="line">link        puintptr   <span class="comment">// p 的链表</span></span><br><span class="line">schedtick   <span class="keyword">uint32</span>     <span class="comment">// incremented on every scheduler call // 每次调度程序调用时增加</span></span><br><span class="line">syscalltick <span class="keyword">uint32</span>     <span class="comment">// incremented on every system call // 每次系统调用时增加</span></span><br><span class="line">sysmontick  sysmontick <span class="comment">// last tick observed by sysmon // sysmon观察到的最后一个tick，会记录</span></span><br><span class="line">m           muintptr   <span class="comment">// back-link to associated m (nil if idle) // 反向链接到相关的M（如果空闲则为nil）</span></span><br><span class="line">mcache      *mcache    <span class="comment">// mcache: 每个P的内存缓存，不需要加锁</span></span><br><span class="line">racectx     <span class="keyword">uintptr</span>    <span class="comment">// 竟态上下文</span></span><br><span class="line"></span><br><span class="line">deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go) // defer池，拥有不同的尺寸</span></span><br><span class="line">deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line"><span class="comment">// goroutine ID的缓存将分摊对runtime.sched.goidgen的访问。</span></span><br><span class="line">goidcache    <span class="keyword">uint64</span></span><br><span class="line">goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line"><span class="comment">// 可运行goroutine队列。 无锁访问。</span></span><br><span class="line"><span class="comment">//  runqhead 和 runqtail 都是 uint32 ，不用担心越界问题，超过最大值之后，会变为 0 ，并且 0 - ^uint32(0) = 1 ，也就是说取长度也不会有问题。</span></span><br><span class="line">runqhead <span class="keyword">uint32</span>        <span class="comment">// 队头，runqhead 在后头跟，指向第一个可以使用，应该从这里取出</span></span><br><span class="line">runqtail <span class="keyword">uint32</span>        <span class="comment">// 队尾，runqtail 在队列前面走，指向第一个空槽，应该插入到这里</span></span><br><span class="line">runq     [<span class="number">256</span>]guintptr <span class="comment">// 运行队列</span></span><br><span class="line"><span class="comment">// runnext, if non-nil, is a runnable G that was ready'd by</span></span><br><span class="line"><span class="comment">// the current G and should be run next instead of what's in</span></span><br><span class="line"><span class="comment">// runq if there's time remaining in the running G's time</span></span><br><span class="line"><span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line"><span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line"><span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line"><span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line"><span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line"><span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line"><span class="comment">// runnext（如果不是nil）是当前G准备好的可运行G，如果正在运行的G的时间片中还有剩余时间，则应在下一个运行，而不是在runq中的G来运行。</span></span><br><span class="line"><span class="comment">// 它将继承当前时间片中剩余的时间。如果将一组goroutine锁定为“通信等待”模式，则将其设置为一个单元进行调度，并消除了（可能较大的）调度</span></span><br><span class="line"><span class="comment">// 延迟，而这种延迟可能是由于将就绪的goroutine添加到运行队列的末尾而引起的。</span></span><br><span class="line">runnext guintptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line"><span class="comment">// 可用的G，状态为Gdead</span></span><br><span class="line">gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">gList</span><br><span class="line">n <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sudogcache []*sudog <span class="comment">// sudog缓存，初始化为： sudogbuf[:0]</span></span><br><span class="line">sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">tracebuf traceBufPtr <span class="comment">// trace缓存，64Kb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line"><span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line"><span class="comment">// has actually been swept.</span></span><br><span class="line"><span class="comment">// traceSweep指示清扫事件是否被trace。这用于推迟清扫开始事件，直到实际扫过一个span为止。</span></span><br><span class="line">traceSweep <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line"><span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line"><span class="comment">// traceSwept和traceReclaimed跟踪通过在当前清扫循环中进行清扫来清除和回收的字节数。</span></span><br><span class="line">traceSwept, traceReclaimed <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">palloc persistentAlloc <span class="comment">// per-P to avoid mutex // 分配器，每个P一个，避免加锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-P GC state</span></span><br><span class="line"><span class="comment">// 每个P的GC状态</span></span><br><span class="line">gcAssistTime         <span class="keyword">int64</span>            <span class="comment">// Nanoseconds in assistAlloc // gcAassistAlloc中计时</span></span><br><span class="line">gcFractionalMarkTime <span class="keyword">int64</span>            <span class="comment">// Nanoseconds in fractional mark worker // GC Mark计时</span></span><br><span class="line">gcBgMarkWorker       guintptr         <span class="comment">// 标记G</span></span><br><span class="line">gcMarkWorkerMode     gcMarkWorkerMode <span class="comment">// 标记模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcMarkWorkerStartTime is the nanotime() at which this mark</span></span><br><span class="line"><span class="comment">// worker started.</span></span><br><span class="line">gcMarkWorkerStartTime <span class="keyword">int64</span> <span class="comment">// mark worker启动时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line"><span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line"><span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line"><span class="comment">// gcw是此P的GC工作缓冲区高速缓存。工作缓冲区由写屏障填充，由辅助mutator(赋值器)耗尽，并放置在某些GC状态转换上。</span></span><br><span class="line">gcw gcWork <span class="comment">//  GC 的本地工作队列，灰色对象管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line"><span class="comment">// wbBuf 是当前 P 的 GC 的 write barrier 缓存</span></span><br><span class="line">wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point // 如果为 1, 则在下一个 safe-point 运行 sched.safePointFn</span></span><br><span class="line"></span><br><span class="line">pad cpu.CacheLinePad</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gobuf"><a href="#gobuf" class="headerlink" title="gobuf"></a>gobuf</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// gobuf记录与协程切换相关信息</span></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">sp   <span class="keyword">uintptr</span>        <span class="comment">// sp 寄存器</span></span><br><span class="line">pc   <span class="keyword">uintptr</span>        <span class="comment">// pc 寄存器</span></span><br><span class="line">g    guintptr       <span class="comment">// g 指针</span></span><br><span class="line">ctxt unsafe.Pointer <span class="comment">// 这个似乎是用来辅助 gc 的</span></span><br><span class="line">ret  sys.Uintreg    <span class="comment">// 作用 ？ panic.go 中 recovery 函数有设置为 1</span></span><br><span class="line">lr   <span class="keyword">uintptr</span>        <span class="comment">// 这是在 arm 上用的寄存器，不用关心</span></span><br><span class="line">bp   <span class="keyword">uintptr</span>        <span class="comment">// for GOEXPERIMENT=framepointer // 开启 GOEXPERIMENT=framepointer ，才会有这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">g0      *g     <span class="comment">// goroutine with scheduling stack // 用于执行调度指令的 goroutine， 用于调度的特殊 g , 调度和执行系统调用时会切换到这个 g</span></span><br><span class="line">morebuf gobuf  <span class="comment">// gobuf arg to morestack //  morestack 的 gobuf 参数</span></span><br><span class="line">divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fields not known to debuggers.</span></span><br><span class="line"><span class="comment">// debugger 不知道的字段</span></span><br><span class="line">procid        <span class="keyword">uint64</span>         <span class="comment">// for debuggers, but offset not hard-coded // 用于 debugger，偏移量不是写死的</span></span><br><span class="line">gsignal       *g             <span class="comment">// signal-handling g // 用于 debugger，偏移量不是写死的</span></span><br><span class="line">goSigStack    gsignalStack   <span class="comment">// Go-allocated signal handling stack // Go 分配的 signal handling 栈</span></span><br><span class="line">sigmask       sigset         <span class="comment">// storage for saved signal mask // 用于保存 saved signal mask</span></span><br><span class="line">tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>     <span class="comment">// thread-local storage (for x86 extern register) // thread-local storage (对 x86 而言为额外的寄存器)</span></span><br><span class="line">mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span>         // <span class="title">M</span>启动函数</span></span><br><span class="line"><span class="function"><span class="title">curg</span>          *<span class="title">g</span>             // <span class="title">current</span> <span class="title">running</span> <span class="title">goroutine</span> // 当前运行的用户 <span class="title">g</span></span></span><br><span class="line"><span class="function"><span class="title">caughtsig</span>     <span class="title">guintptr</span>       // <span class="title">goroutine</span> <span class="title">running</span> <span class="title">during</span> <span class="title">fatal</span> <span class="title">signal</span> // <span class="title">goroutine</span> 在 <span class="title">fatal</span> <span class="title">signal</span> 中运行</span></span><br><span class="line"><span class="function"><span class="title">p</span>             <span class="title">puintptr</span>       // <span class="title">attached</span> <span class="title">p</span> <span class="title">for</span> <span class="title">executing</span> <span class="title">go</span> <span class="title">code</span> <span class="params">(<span class="literal">nil</span> <span class="keyword">if</span> not executing <span class="keyword">go</span> code)</span> // 执行 <span class="title">go</span> 代码时持有的 <span class="title">p</span> <span class="params">(如果没有执行则为 <span class="literal">nil</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">nextp</span>         <span class="title">puintptr</span>       // 下一个<span class="title">p</span>， 唤醒 <span class="title">M</span> 时,  <span class="title">M</span> 会拥有这个 <span class="title">P</span></span></span><br><span class="line"><span class="function"><span class="title">oldp</span>          <span class="title">puintptr</span>       // <span class="title">the</span> <span class="title">p</span> <span class="title">that</span> <span class="title">was</span> <span class="title">attached</span> <span class="title">before</span> <span class="title">executing</span> <span class="title">a</span> <span class="title">syscall</span> // 执行系统调用之前绑定的 <span class="title">p</span></span></span><br><span class="line"><span class="function"><span class="title">id</span>            <span class="title">int64</span>          // <span class="title">ID</span></span></span><br><span class="line"><span class="function"><span class="title">mallocing</span>     <span class="title">int32</span>          // 是否正在分配内存</span></span><br><span class="line"><span class="function"><span class="title">throwing</span>      <span class="title">int32</span>          // 是否正在抛出异常</span></span><br><span class="line"><span class="function"><span class="title">preemptoff</span>    <span class="title">string</span>         // <span class="title">if</span> != "", <span class="title">keep</span> <span class="title">curg</span> <span class="title">running</span> <span class="title">on</span> <span class="title">this</span> <span class="title">m</span> // 如果不为空串 ""，继续让当前 <span class="title">g</span> 运行在该 <span class="title">M</span> 上</span></span><br><span class="line"><span class="function"><span class="title">locks</span>         <span class="title">int32</span>          // <span class="title">M</span>的锁</span></span><br><span class="line"><span class="function"><span class="title">dying</span>         <span class="title">int32</span>          // 是否正在死亡，参见<span class="title">startpanic_m</span></span></span><br><span class="line"><span class="function"><span class="title">profilehz</span>     <span class="title">int32</span>          // <span class="title">cpu</span> <span class="title">profiling</span> <span class="title">rate</span></span></span><br><span class="line"><span class="function"><span class="title">spinning</span>      <span class="title">bool</span>           // <span class="title">m</span> <span class="title">is</span> <span class="title">out</span> <span class="title">of</span> <span class="title">work</span> <span class="title">and</span> <span class="title">is</span> <span class="title">actively</span> <span class="title">looking</span> <span class="title">for</span> <span class="title">work</span> // <span class="title">m</span> 当前没有运行 <span class="title">work</span> 且正处于寻找 <span class="title">work</span> 的活跃状态</span></span><br><span class="line"><span class="function"><span class="title">blocked</span>       <span class="title">bool</span>           // <span class="title">m</span> <span class="title">is</span> <span class="title">blocked</span> <span class="title">on</span> <span class="title">a</span> <span class="title">note</span> // <span class="title">m</span> 阻塞在一个 <span class="title">note</span> 上</span></span><br><span class="line"><span class="function"><span class="title">inwb</span>          <span class="title">bool</span>           // <span class="title">m</span> <span class="title">is</span> <span class="title">executing</span> <span class="title">a</span> <span class="title">write</span> <span class="title">barrier</span> // <span class="title">m</span> 在执行<span class="title">write</span> <span class="title">barrier</span></span></span><br><span class="line"><span class="function"><span class="title">newSigstack</span>   <span class="title">bool</span>           // <span class="title">minit</span> <span class="title">on</span> <span class="title">C</span> <span class="title">thread</span> <span class="title">called</span> <span class="title">sigaltstack</span> // <span class="title">C</span> 线程上的 <span class="title">minit</span> 是否调用了 <span class="title">signalstack</span></span></span><br><span class="line"><span class="function"><span class="title">printlock</span>     <span class="title">int8</span>           // <span class="title">print</span> 锁，参见 <span class="title">print</span>.<span class="title">go</span> <span class="title">printlock</span>/<span class="title">printunlock</span></span></span><br><span class="line"><span class="function"><span class="title">incgo</span>         <span class="title">bool</span>           // <span class="title">m</span> <span class="title">is</span> <span class="title">executing</span> <span class="title">a</span> <span class="title">cgo</span> <span class="title">call</span> // <span class="title">m</span> 正在执行 <span class="title">cgo</span> 调用</span></span><br><span class="line"><span class="function"><span class="title">freeWait</span>      <span class="title">uint32</span>         // <span class="title">if</span> == 0, <span class="title">safe</span> <span class="title">to</span> <span class="title">free</span> <span class="title">g0</span> <span class="title">and</span> <span class="title">delete</span> <span class="title">m</span> <span class="params">(atomic)</span> // 如果为 0，安全的释放 <span class="title">g0</span> 并删除 <span class="title">m</span> <span class="params">(原子操作)</span></span></span><br><span class="line"><span class="function"><span class="title">fastrand</span>      [2]<span class="title">uint32</span>      // 快速随机</span></span><br><span class="line"><span class="function"><span class="title">needextram</span>    <span class="title">bool</span>           // 需要额外的 <span class="title">m</span></span></span><br><span class="line"><span class="function"><span class="title">traceback</span>     <span class="title">uint8</span>          // 回溯</span></span><br><span class="line"><span class="function"><span class="title">ncgocall</span>      <span class="title">uint64</span>         // <span class="title">number</span> <span class="title">of</span> <span class="title">cgo</span> <span class="title">calls</span> <span class="title">in</span> <span class="title">total</span> // 总共的 <span class="title">cgo</span> 调用数</span></span><br><span class="line"><span class="function"><span class="title">ncgo</span>          <span class="title">int32</span>          // <span class="title">number</span> <span class="title">of</span> <span class="title">cgo</span> <span class="title">calls</span> <span class="title">currently</span> <span class="title">in</span> <span class="title">progress</span> // 正在进行的 <span class="title">cgo</span> 调用数</span></span><br><span class="line"><span class="function"><span class="title">cgoCallersUse</span> <span class="title">uint32</span>         // <span class="title">if</span> <span class="title">non</span>-<span class="title">zero</span>, <span class="title">cgoCallers</span> <span class="title">in</span> <span class="title">use</span> <span class="title">temporarily</span> // 如果非零，则表示 <span class="title">cgoCaller</span> 正在临时使用</span></span><br><span class="line"><span class="function"><span class="title">cgoCallers</span>    *<span class="title">cgoCallers</span>    // <span class="title">cgo</span> <span class="title">traceback</span> <span class="title">if</span> <span class="title">crashing</span> <span class="title">in</span> <span class="title">cgo</span> <span class="title">call</span> // <span class="title">cgo</span> 调用崩溃的 <span class="title">cgo</span> 回溯</span></span><br><span class="line"><span class="function"><span class="title">park</span>          <span class="title">note</span>           //  <span class="title">M</span> 休眠时使用的信号量, 唤醒 <span class="title">M</span> 时会通过它唤醒</span></span><br><span class="line"><span class="function"><span class="title">alllink</span>       *<span class="title">m</span>             // <span class="title">on</span> <span class="title">allm</span> // 在 <span class="title">allm</span> 上，将所有的 <span class="title">m</span> 链接起来</span></span><br><span class="line"><span class="function"><span class="title">schedlink</span>     <span class="title">muintptr</span>       // 下一个 <span class="title">m</span> , 当 <span class="title">m</span> 在链表结构中会使用</span></span><br><span class="line"><span class="function"><span class="title">mcache</span>        *<span class="title">mcache</span>        // 分配内存时使用的本地分配器, 和 <span class="title">p</span>.<span class="title">mcache</span> 一样<span class="params">(拥有 P 时会复制过来)</span></span></span><br><span class="line"><span class="function"><span class="title">lockedg</span>       <span class="title">guintptr</span>       // 表示与当前 <span class="title">M</span> 锁定的那个 <span class="title">G</span> 。运行时系统会把 一个 <span class="title">M</span> 和一个 <span class="title">G</span> 锁定，一旦锁定就只能双方相互作用，不接受第三者。<span class="title">g</span>.<span class="title">lockedm</span> 的对应值</span></span><br><span class="line"><span class="function"><span class="title">createstack</span>   [32]<span class="title">uintptr</span>    // <span class="title">stack</span> <span class="title">that</span> <span class="title">created</span> <span class="title">this</span> <span class="title">thread</span>.// 当前线程创建的栈</span></span><br><span class="line"><span class="function"><span class="title">lockedExt</span>     <span class="title">uint32</span>         // <span class="title">tracking</span> <span class="title">for</span> <span class="title">external</span> <span class="title">LockOSThread</span> // 外部 <span class="title">LockOSThread</span> 追踪，<span class="title">LockOSThread</span>/<span class="title">UnlockOSThread</span></span></span><br><span class="line"><span class="function"><span class="title">lockedInt</span>     <span class="title">uint32</span>         // <span class="title">tracking</span> <span class="title">for</span> <span class="title">internal</span> <span class="title">lockOSThread</span> // 内部 <span class="title">lockOSThread</span> 追踪，<span class="title">lockOSThread</span>/<span class="title">unlockOSThread</span></span></span><br><span class="line"><span class="function"><span class="title">nextwaitm</span>     <span class="title">muintptr</span>       // <span class="title">next</span> <span class="title">m</span> <span class="title">waiting</span> <span class="title">for</span> <span class="title">lock</span> // 内部 <span class="title">lockOSThread</span> 追踪</span></span><br><span class="line"><span class="function"><span class="title">waitunlockf</span>   <span class="title">unsafe</span>.<span class="title">Pointer</span> // <span class="title">todo</span> <span class="title">go</span> <span class="title">func</span><span class="params">(*g, unsafe.pointer)</span> <span class="title">bool</span> // 参见<span class="title">proc</span>.<span class="title">go</span> <span class="title">gopark</span></span></span><br><span class="line"><span class="function"><span class="title">waitlock</span>      <span class="title">unsafe</span>.<span class="title">Pointer</span> // 参见<span class="title">proc</span>.<span class="title">go</span> <span class="title">gopark</span></span></span><br><span class="line"><span class="function"><span class="title">waittraceev</span>   <span class="title">byte</span>           // 参见<span class="title">proc</span>.<span class="title">go</span> <span class="title">gopark</span></span></span><br><span class="line"><span class="function"><span class="title">waittraceskip</span> <span class="title">int</span>            // 参见<span class="title">proc</span>.<span class="title">go</span> <span class="title">gopark</span></span></span><br><span class="line"><span class="function"><span class="title">startingtrace</span> <span class="title">bool</span>           // 开始<span class="title">trace</span>，见<span class="title">trace</span>.<span class="title">go</span> <span class="title">StartTrace</span></span></span><br><span class="line"><span class="function"><span class="title">syscalltick</span>   <span class="title">uint32</span>         // 每次系统调用时增加</span></span><br><span class="line"><span class="function"><span class="title">thread</span>        <span class="title">uintptr</span>        // <span class="title">thread</span> <span class="title">handle</span> // 线程句柄</span></span><br><span class="line"><span class="function"><span class="title">freelink</span>      *<span class="title">m</span>             // <span class="title">on</span> <span class="title">sched</span>.<span class="title">freem</span> // 在 <span class="title">sched</span>.<span class="title">freem</span> 上</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">these</span> <span class="title">are</span> <span class="title">here</span> <span class="title">because</span> <span class="title">they</span> <span class="title">are</span> <span class="title">too</span> <span class="title">large</span> <span class="title">to</span> <span class="title">be</span> <span class="title">on</span> <span class="title">the</span> <span class="title">stack</span></span></span><br><span class="line"><span class="function">// <span class="title">of</span> <span class="title">low</span>-<span class="title">level</span> <span class="title">NOSPLIT</span> <span class="title">functions</span>.</span></span><br><span class="line"><span class="function">// 下面这些字段因为它们太大而不能放在低级的 <span class="title">NOSPLIT</span> 函数的堆栈上。</span></span><br><span class="line"><span class="function"><span class="title">libcall</span>   <span class="title">libcall</span>  // 调用信息</span></span><br><span class="line"><span class="function"><span class="title">libcallpc</span> <span class="title">uintptr</span>  // <span class="title">for</span> <span class="title">cpu</span> <span class="title">profiler</span> // 用于 <span class="title">cpu</span> <span class="title">profiler</span></span></span><br><span class="line"><span class="function"><span class="title">libcallsp</span> <span class="title">uintptr</span>  // <span class="title">libcall</span> <span class="title">SP</span></span></span><br><span class="line"><span class="function"><span class="title">libcallg</span>  <span class="title">guintptr</span> // <span class="title">libcall</span> <span class="title">G</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span>   <span class="title">libcall</span>  // <span class="title">stores</span> <span class="title">syscall</span> <span class="title">parameters</span> <span class="title">on</span> <span class="title">windows</span> // 存储 <span class="title">windows</span> 上系统调用的参数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">vdsoSP</span> <span class="title">uintptr</span> // <span class="title">SP</span> <span class="title">for</span> <span class="title">traceback</span> <span class="title">while</span> <span class="title">in</span> <span class="title">VDSO</span> <span class="title">call</span> <span class="params">(0 <span class="keyword">if</span> not in call)</span></span></span><br><span class="line"><span class="function"><span class="title">vdsoPC</span> <span class="title">uintptr</span> // <span class="title">PC</span> <span class="title">for</span> <span class="title">traceback</span> <span class="title">while</span> <span class="title">in</span> <span class="title">VDSO</span> <span class="title">call</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">mOS</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="schedt"><a href="#schedt" class="headerlink" title="schedt"></a>schedt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// accessed atomically. keep at top to ensure alignment on 32-bit systems.</span></span><br><span class="line"><span class="comment">// 原子访问，放到顶部，确保在32位系统上对齐（8字节）。</span></span><br><span class="line">goidgen  <span class="keyword">uint64</span> <span class="comment">// go runtime ID生成器，原子自增，在newproc1和oneNewExtraM中使用了</span></span><br><span class="line">lastpoll <span class="keyword">uint64</span> <span class="comment">// 上一次轮询的时间（nanotime）</span></span><br><span class="line"></span><br><span class="line">lock mutex <span class="comment">// 锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span></span><br><span class="line"><span class="comment">// sure to call checkdead().</span></span><br><span class="line"><span class="comment">// 当增加nmidle，nmidlelocked，nmsys或nmfreed时，请确保调用checkdead()。</span></span><br><span class="line"></span><br><span class="line">midle        muintptr <span class="comment">// idle m's waiting for work // 空闲的 M 队列</span></span><br><span class="line">nmidle       <span class="keyword">int32</span>    <span class="comment">// number of idle m's waiting for work // 当前等待工作的空闲 M 计数</span></span><br><span class="line">nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m's waiting for work // 当前等待工作的被 lock 的 M 计数</span></span><br><span class="line">mnext        <span class="keyword">int64</span>    <span class="comment">// number of m's that have been created and next M ID // 已经被创建的 M 的数量，下一个 M 的 ID</span></span><br><span class="line">maxmcount    <span class="keyword">int32</span>    <span class="comment">// maximum number of m's allowed (or die) // 最大M的数量</span></span><br><span class="line">nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock // 系统 M 的数量， 在 deadlock 中不计数</span></span><br><span class="line">nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's// 释放的 M 的累计数量</span></span><br><span class="line"></span><br><span class="line">ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically // 系统调用 goroutine 的数量，原子更新</span></span><br><span class="line"></span><br><span class="line">pidle      puintptr <span class="comment">// idle p's // 空闲的P</span></span><br><span class="line">npidle     <span class="keyword">uint32</span>   <span class="comment">// 空闲的P的数目</span></span><br><span class="line">nmspinning <span class="keyword">uint32</span>   <span class="comment">// See "Worker thread parking/unparking" comment in proc.go. // 处于spinning的M的数目</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global runnable queue.</span></span><br><span class="line">runq     gQueue <span class="comment">// 全局的 G 运行队列</span></span><br><span class="line">runqsize <span class="keyword">int32</span>  <span class="comment">// 全局的 G 运行队列大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// disable controls selective disabling of the scheduler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use schedEnableUser to control this.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// disable is protected by sched.lock.</span></span><br><span class="line"><span class="comment">// disable控制选择性禁用调度程序。使用schedEnableUser进行控制。受sched.lock保护。</span></span><br><span class="line">disable <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// user disables scheduling of user goroutines.</span></span><br><span class="line">user     <span class="keyword">bool</span>   <span class="comment">// 用户禁用用户的goroutines调度</span></span><br><span class="line">runnable gQueue <span class="comment">// pending runnable Gs // 等待的可运行的G队列</span></span><br><span class="line">n        <span class="keyword">int32</span>  <span class="comment">// length of runnable // runnable的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Global cache of dead G's.</span></span><br><span class="line"><span class="comment">// dead G全局缓存，已退出的 goroutine 对象缓存下来，避免每次创建 goroutine 时都重新分配内存，可参考proc.go中的gfput,gfget</span></span><br><span class="line">gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">lock    mutex <span class="comment">// 锁</span></span><br><span class="line">stack   gList <span class="comment">// Gs with stacks // 有堆栈的G</span></span><br><span class="line">noStack gList <span class="comment">// Gs without stacks // 没有堆栈的G</span></span><br><span class="line">n       <span class="keyword">int32</span> <span class="comment">// stack和noStack中的总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">sudoglock  mutex  <span class="comment">// sudog缓存的锁</span></span><br><span class="line">sudogcache *sudog <span class="comment">// sudog缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Central pool of available defer structs of different sizes.</span></span><br><span class="line">deferlock mutex      <span class="comment">// defer缓存的锁</span></span><br><span class="line">deferpool [<span class="number">5</span>]*_defer <span class="comment">// defer缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// freem is the list of m's waiting to be freed when their</span></span><br><span class="line"><span class="comment">// m.exited is set. Linked through m.freelink.</span></span><br><span class="line">freem *m <span class="comment">// freem是设置 m.exited 时等待释放的 m 列表。通过 m.freelink 链接。</span></span><br><span class="line"></span><br><span class="line">gcwaiting  <span class="keyword">uint32</span> <span class="comment">// gc is waiting to run // GC等待运行</span></span><br><span class="line">stopwait   <span class="keyword">int32</span>  <span class="comment">// 需要停止P的数目</span></span><br><span class="line">stopnote   note   <span class="comment">// stopwait睡眠唤醒事件</span></span><br><span class="line">sysmonwait <span class="keyword">uint32</span> <span class="comment">// 等待系统监控</span></span><br><span class="line">sysmonnote note   <span class="comment">// sysmonwait睡眠唤醒事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// safepointFn should be called on each P at the next GC</span></span><br><span class="line"><span class="comment">// safepoint if p.runSafePointFn is set.</span></span><br><span class="line"><span class="comment">// 如果设置了p.runSafePointFn，则应在下一个GC安全点的每个P上调用safepointFn。</span></span><br><span class="line">safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span> // 安全点函数</span></span><br><span class="line"><span class="function"><span class="title">safePointWait</span> <span class="title">int32</span>    // 等待<span class="title">safePointFn</span>执行</span></span><br><span class="line"><span class="function"><span class="title">safePointNote</span> <span class="title">note</span>     // <span class="title">safePointWait</span>睡眠唤醒事件</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">profilehz</span> <span class="title">int32</span> // <span class="title">cpu</span> <span class="title">profiling</span> <span class="title">rate</span> // <span class="title">CPU</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">procresizetime</span> <span class="title">int64</span> // <span class="title">nanotime</span><span class="params">()</span> <span class="title">of</span> <span class="title">last</span> <span class="title">change</span> <span class="title">to</span> <span class="title">gomaxprocs</span> // 上一次修改<span class="title">gomaxprocs</span>的时间，参见<span class="title">proc</span>.<span class="title">go</span>中的<span class="title">procresize</span></span></span><br><span class="line"><span class="function"><span class="title">totaltime</span>      <span class="title">int64</span> // ∫<span class="title">gomaxprocs</span> <span class="title">dt</span> <span class="title">up</span> <span class="title">to</span> <span class="title">procresizetime</span> // 总时间</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Global-objects"><a href="#Global-objects" class="headerlink" title="Global objects"></a>Global objects</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// 全局的一些对象</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">allglen    <span class="keyword">uintptr</span>      <span class="comment">// 所有G的数目</span></span><br><span class="line">allm       *m           <span class="comment">// 所有的M</span></span><br><span class="line">allp       []*p         <span class="comment">// len(allp) == gomaxprocs; may change at safe points, otherwise immutable // 可能在安全区更改，否则不变</span></span><br><span class="line">allpLock   mutex        <span class="comment">// Protects P-less reads of allp and all writes // allp的锁</span></span><br><span class="line">gomaxprocs <span class="keyword">int32</span>        <span class="comment">// GOMAXPROCS</span></span><br><span class="line">ncpu       <span class="keyword">int32</span>        <span class="comment">// CPU数目</span></span><br><span class="line">forcegc    forcegcstate <span class="comment">// 强制GC</span></span><br><span class="line">sched      schedt       <span class="comment">// 调度</span></span><br><span class="line">newprocs   <span class="keyword">int32</span>        <span class="comment">// GOMAXPROCS函数设置，startTheWorld处理</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">m0           m <span class="comment">// 主M，asm_amd64.s中runtime·rt0_go初始化</span></span><br><span class="line">g0           g <span class="comment">// 主G，asm_amd64.s中runtime·rt0_go初始化</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>&emsp;&emsp;这里主要介绍 GPM 的一些基础概念。下一篇，将介绍 GMP 的调度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我们知道 golang 原生支持并发，goroutine 就是其设计的核心。 goroutine 是用户态线程，也就是协程。这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，当然这不需要我们做什么工作，golang 已经帮我们处理了。在如今处处高并发的时代，很多库包括语言都有协程的影子。例如，腾讯的 &lt;a href=&quot;https://github.com/tencent/libco&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libco&lt;/a&gt; 是微信后台大规模使用的c/c++协程库；lua 也是有协程的。&lt;/p&gt;
    
    </summary>
    
      <category term="【golang源码分析】" scheme="https://veezhang.github.io/categories/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91/"/>
    
    
      <category term="golang" scheme="https://veezhang.github.io/tags/golang/"/>
    
      <category term="源码分析" scheme="https://veezhang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【golang源码分析】之内存管理</title>
    <link href="https://veezhang.github.io/2019/09/11/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://veezhang.github.io/2019/09/11/【golang源码分析】之内存管理/</id>
    <published>2019-09-11T12:15:10.000Z</published>
    <updated>2020-05-15T08:27:03.418Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="【golang源码分析】" scheme="https://veezhang.github.io/categories/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91/"/>
    
    
      <category term="golang" scheme="https://veezhang.github.io/tags/golang/"/>
    
      <category term="源码分析" scheme="https://veezhang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes-hello-world</title>
    <link href="https://veezhang.github.io/2019/09/10/kubernetes-hello-world/"/>
    <id>https://veezhang.github.io/2019/09/10/kubernetes-hello-world/</id>
    <published>2019-09-10T19:10:16.000Z</published>
    <updated>2020-05-13T05:50:24.904Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;记录一下以前给公司员工<code>kubernetes</code>的入门培训 <a href="https://github.com/veezhang/kubernetes-hello-world" target="_blank" rel="noopener">kubernetes-hello-world</a></p><p>&emsp;&emsp;从基础知识到实战讲解<code>kubernetes</code>。实现了一个简单的类似浏览器访问量的功能（只是注重对<code>kubernetes</code>的了解）。详情请访问<a href="https://github.com/veezhang/kubernetes-hello-world" target="_blank" rel="noopener">kubernetes-hello-world</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;记录一下以前给公司员工&lt;code&gt;kubernetes&lt;/code&gt;的入门培训 &lt;a href=&quot;https://github.com/veezhang/kubernetes-hello-world&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
      <category term="kubernetes" scheme="https://veezhang.github.io/categories/kubernetes/"/>
    
      <category term="k8s" scheme="https://veezhang.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="https://veezhang.github.io/tags/k8s/"/>
    
      <category term="kubernetes" scheme="https://veezhang.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>【golang源码分析】之启动追踪</title>
    <link href="https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E5%90%AF%E5%8A%A8%E8%BF%BD%E8%B8%AA/"/>
    <id>https://veezhang.github.io/2019/09/05/【golang源码分析】之启动追踪/</id>
    <published>2019-09-05T21:00:56.000Z</published>
    <updated>2020-05-13T05:50:25.176Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;很多人也许对Go代码是怎么启动的比较感兴趣， 我也不例外。 因此在这里调试下代码， 看看到底是怎么启动的， 并在此做下记录, 暂时不会逐行分析，只是了解下Go的启动流程。（关于环境，在第一篇<a href="https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/#more">【golang源码分析】之源码结构</a>中已经提到过， 如无特殊说明后续相关的都是基于此环境，不再提及。）</p><a id="more"></a><h2 id="安装go1-12-9"><a href="#安装go1-12-9" class="headerlink" title="安装go1.12.9"></a>安装go1.12.9</h2><p>&emsp;&emsp;应为需要调试源代码，所以这里源码安装go， 并禁止优化和内联。我是ubuntu18.04环境，其他环境类似。</p><p>&emsp;&emsp;这里采用了docker来安装， github地址<a href="https://github.com/veezhanggo-src-debug-docker" target="_blank" rel="noopener">go-src-debug-docker</a>, 并且镜像已经推到<code>hub</code>上面了<a href="https://hub.docker.com/r/veezhanggo-src-debug" target="_blank" rel="noopener">go-src-debug</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动docker</span><br><span class="line"><span class="meta">#</span> 如果需要映射卷的， 请加上-v选项</span><br><span class="line"><span class="meta">#</span> 这里需要给--privileged， 不然gdb有问题</span><br><span class="line">docker run -it -d --privileged --name go-src-debug veezhanggo-src-debug:1.12.9</span><br><span class="line"><span class="meta">#</span> 进入docker</span><br><span class="line">docker exec -it go-src-debug bash</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注： 如无特殊说明，后续的调试都是在docker下执行。</p><h2 id="调试代码样例"><a href="#调试代码样例" class="headerlink" title="调试代码样例"></a>调试代码样例</h2><p>&emsp;&emsp;这里写了一个简单的代码(main.go)来进行启动追踪， 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, I'm Vee Zhang."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>&emsp;&emsp;Go打包的程序和C打包的程序一样在linux系统上是 elf 格式的。编译参数我们添加了 <code>-gcflags</code> 编译参数， 编译命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> -N    disable optimizations   禁止优化</span><br><span class="line"><span class="meta">#</span> -l    disable inlining        禁止内联</span><br><span class="line">go build -gcflags "-N -l" -o main main.go</span><br><span class="line"><span class="meta">#</span> 执行下，看看是否正常</span><br><span class="line">./main</span><br><span class="line">Hello, I'm Vee Zhang.</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>&emsp;&emsp;使用 <code>gdb</code> 进行调试， 由于添加了部分注释，可能会导致gdb行号对不上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gdb ./main</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</span><br><span class="line">and "show warranty" for details.</span><br><span class="line">This GDB was configured as "x86_64-linux-gnu".</span><br><span class="line">Type "show configuration" for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type "help".</span><br><span class="line">Type "apropos word" to search for commands related to "word"...</span><br><span class="line">Reading symbols from ./main...done.</span><br><span class="line">warning: File "go/src/runtime/runtime-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".</span><br><span class="line">To enable execution of this file add</span><br><span class="line">        add-auto-load-safe-path go/src/runtime/runtime-gdb.py</span><br><span class="line">line to your configuration file "/root/.gdbinit".</span><br><span class="line">To completely disable this security protection add</span><br><span class="line">        set auto-load safe-path /</span><br><span class="line">line to your configuration file "/root/.gdbinit".</span><br><span class="line">For more information about this security protection see the</span><br><span class="line">"Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:</span><br><span class="line">        info "(gdb)Auto-loading safe path"</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在gdb命令行输入： <code>info files</code>， 可以看到main的<code>Entry point</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info files</span><br><span class="line">Symbols from "/main".</span><br><span class="line">Local exec file:</span><br><span class="line">        `/main', file type elf64-x86-64.</span><br><span class="line">        Entry point: 0x452890</span><br><span class="line">        0x0000000000401000 - 0x0000000000487304 is .text</span><br><span class="line">        0x0000000000488000 - 0x00000000004d2ac0 is .rodata</span><br><span class="line">        0x00000000004d2c60 - 0x00000000004d3834 is .typelink</span><br><span class="line">        0x00000000004d3838 - 0x00000000004d3880 is .itablink</span><br><span class="line">        0x00000000004d3880 - 0x00000000004d3880 is .gosymtab</span><br><span class="line">        0x00000000004d3880 - 0x00000000005433e6 is .gopclntab</span><br><span class="line">        0x0000000000544000 - 0x0000000000550a9c is .noptrdata</span><br><span class="line">        0x0000000000550aa0 - 0x0000000000557790 is .data</span><br><span class="line">        0x00000000005577a0 - 0x0000000000572ef0 is .bss</span><br><span class="line">        0x0000000000572f00 - 0x0000000000575658 is .noptrbss</span><br><span class="line">        0x0000000000400f9c - 0x0000000000401000 is .note.go.buildid</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在<code>Entry point</code>的指针上打算断点<code>b *0x452890</code>, 并启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x452890</span><br><span class="line">Breakpoint 1 at 0x452890: file go/src/runtime/rt0_linux_amd64.s, line 8.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /main</span><br><span class="line"></span><br><span class="line">Breakpoint 1, _rt0_amd64_linux () at go/src/runtime/rt0_linux_amd64.s:8</span><br><span class="line">8               JMP     _rt0_amd64(SB)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，该断点在文件<code>go/src/runtime/rt0_linux_amd64.s</code>的第<code>8</code>行， 我们打开看看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line">#include <span class="string">"textflag.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  linux amd64 系统的启动函数</span></span><br><span class="line">TEXT _rt0_amd64_linux(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">    JMP _rt0_amd64(SB) <span class="comment">// 跳转到_rt0_amd64函数， 在 asm_amd64.s 中。</span></span><br><span class="line"></span><br><span class="line">TEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">    JMP _rt0_amd64_lib(SB)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注： 不同的平台有不同的程序入口, 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">go/src/runtime/rt0_aix_ppc64.s</span><br><span class="line">go/src/runtime/rt0_android_386.s</span><br><span class="line">go/src/runtime/rt0_android_amd64.s</span><br><span class="line">go/src/runtime/rt0_android_arm.s</span><br><span class="line">go/src/runtime/rt0_android_arm64.s</span><br><span class="line">go/src/runtime/rt0_darwin_386.s</span><br><span class="line">go/src/runtime/rt0_darwin_amd64.s</span><br><span class="line">go/src/runtime/rt0_darwin_arm.s</span><br><span class="line">go/src/runtime/rt0_darwin_arm64.s</span><br><span class="line">go/src/runtime/rt0_dragonfly_amd64.s</span><br><span class="line">go/src/runtime/rt0_freebsd_386.s</span><br><span class="line">go/src/runtime/rt0_freebsd_amd64.s</span><br><span class="line">go/src/runtime/rt0_freebsd_arm.s</span><br><span class="line">go/src/runtime/rt0_js_wasm.s</span><br><span class="line">go/src/runtime/rt0_linux_386.s</span><br><span class="line">go/src/runtime/rt0_linux_amd64.s</span><br><span class="line">go/src/runtime/rt0_linux_arm.s</span><br><span class="line">go/src/runtime/rt0_linux_arm64.s</span><br><span class="line">go/src/runtime/rt0_linux_mips64x.s</span><br><span class="line">go/src/runtime/rt0_linux_mipsx.s</span><br><span class="line">go/src/runtime/rt0_linux_ppc64.s</span><br><span class="line">go/src/runtime/rt0_linux_ppc64le.s</span><br><span class="line">go/src/runtime/rt0_linux_s390x.s</span><br><span class="line">go/src/runtime/rt0_nacl_386.s</span><br><span class="line">go/src/runtime/rt0_nacl_amd64p32.s</span><br><span class="line">go/src/runtime/rt0_nacl_arm.s</span><br><span class="line">go/src/runtime/rt0_netbsd_386.s</span><br><span class="line">go/src/runtime/rt0_netbsd_amd64.s</span><br><span class="line">go/src/runtime/rt0_netbsd_arm.s</span><br><span class="line">go/src/runtime/rt0_openbsd_386.s</span><br><span class="line">go/src/runtime/rt0_openbsd_amd64.s</span><br><span class="line">go/src/runtime/rt0_openbsd_arm.s</span><br><span class="line">go/src/runtime/rt0_plan9_386.s</span><br><span class="line">go/src/runtime/rt0_plan9_amd64.s</span><br><span class="line">go/src/runtime/rt0_plan9_arm.s</span><br><span class="line">go/src/runtime/rt0_solaris_amd64.s</span><br><span class="line">go/src/runtime/rt0_windows_386.s</span><br><span class="line">go/src/runtime/rt0_windows_amd64.s</span><br><span class="line">go/src/runtime/rt0_windows_arm.s</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从<code>go/src/runtime/rt0_linux_amd64.s</code>文件我们可以知道，跳转到<code>_rt0_amd64</code>了， 再设置断点， 并继续调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b _rt0_amd64</span><br><span class="line">Breakpoint 2 at 0x44ef70: file go/src/runtime/asm_amd64.s, line 15.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, _rt0_amd64 () at go/src/runtime/asm_amd64.s:15</span><br><span class="line">15              MOVQ    0(SP), DI       // argc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着打开<code>go/src/runtime/asm_amd64.s</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line">#include <span class="string">"go_asm.h"</span></span><br><span class="line">#include <span class="string">"go_tls.h"</span></span><br><span class="line">#include <span class="string">"funcdata.h"</span></span><br><span class="line">#include <span class="string">"textflag.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _rt0_amd64 is common startup code for most amd64 systems when using</span></span><br><span class="line"><span class="comment">// internal linking. This is the entry point for the program from the</span></span><br><span class="line"><span class="comment">// kernel for an ordinary -buildmode=exe program. The stack holds the</span></span><br><span class="line"><span class="comment">// number of arguments and the C-style argv.</span></span><br><span class="line"><span class="comment">// _rt0_amd64 是使用内部链接时大多数amd64系统的通用启动代码。 这是内核中普通 -buildmode=exe 程序的入口点。</span></span><br><span class="line"><span class="comment">// 栈保存了参数的数量以及 C 风格的 argv</span></span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span></span><br><span class="line">    MOVQ    <span class="number">0</span>(SP), DI   <span class="comment">// argc     //  设置参数argc</span></span><br><span class="line">    LEAQ    <span class="number">8</span>(SP), SI   <span class="comment">// argv     //  设置参数argv</span></span><br><span class="line">    JMP runtime·rt0_go(SB)          <span class="comment">//  跳转到runtime·rt0_go</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从<code>go/src/runtime/asm_amd64.s</code>文件我们可以知道，设置参数后跳转到<code>runtime·rt0_go</code>了， 再设置断点：</p><p>&emsp;&emsp;注意： 断点设置为<code>runtime.rt0_go</code>, 中间的 <code>·</code> 换成下面的 <code>.</code>， 下同 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b runtime.rt0_go</span><br><span class="line">Breakpoint 3 at 0x44ef80: file go/src/runtime/asm_amd64.s, line 89.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 3, runtime.rt0_go () at go/src/runtime/asm_amd64.s:89</span><br><span class="line">89              MOVQ    DI, AX          // argc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，还在文件<code>go/src/runtime/asm_amd64.s</code>中， 定义在<code>87</code>行, 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line"><span class="comment">// copy arguments forward on an even stack</span></span><br><span class="line"><span class="comment">// 将参数向前复制到一个偶数栈上</span></span><br><span class="line">MOVQDI, AX<span class="comment">// argc// 获取之前设置的argc参数</span></span><br><span class="line">MOVQSI, BX<span class="comment">// argv// 获取之前设置的argv参数</span></span><br><span class="line">SUBQ$(<span class="number">4</span>*<span class="number">8</span>+<span class="number">7</span>), SP<span class="comment">// 2args 2auto</span></span><br><span class="line">ANDQ$~<span class="number">15</span>, SP<span class="comment">// 字节对齐</span></span><br><span class="line">MOVQAX, <span class="number">16</span>(SP)</span><br><span class="line">MOVQBX, <span class="number">24</span>(SP)</span><br><span class="line"></span><br><span class="line"><span class="comment">// create istack out of the given (operating system) stack.</span></span><br><span class="line"><span class="comment">// _cgo_init may update stackguard.</span></span><br><span class="line"><span class="comment">// 从给定（操作系统）栈中创建 istack 。 _cgo_init 可能更新 stackguard</span></span><br><span class="line"><span class="comment">// runtime.g0 位于 runtime/proc.go</span></span><br><span class="line"><span class="comment">// 初始化 g0，g0 的栈实际上就是 linux 分配的栈，大约 64k。</span></span><br><span class="line">MOVQ$runtime·g0(SB), DI<span class="comment">//  DI = runtime·g0</span></span><br><span class="line">LEAQ(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX<span class="comment">//  BX = SP-64*1024+104</span></span><br><span class="line">MOVQBX, g_stackguard0(DI)<span class="comment">//  g0.stackguard0 = SP-64*1024+104</span></span><br><span class="line">MOVQBX, g_stackguard1(DI)<span class="comment">//  g0.stackguard1 = g0.stackguard0</span></span><br><span class="line">MOVQBX, (g_stack+stack_lo)(DI)<span class="comment">//  g0.stack.lo = g0.stackguard0</span></span><br><span class="line">MOVQSP, (g_stack+stack_hi)(DI)<span class="comment">//  g0.stack.hi = SP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find out information about the processor we're on</span></span><br><span class="line"><span class="comment">// 寻找正在运行的处理器信息</span></span><br><span class="line">MOVL$<span class="number">0</span>, AX<span class="comment">//  AX = 0 ，CPUID 参数？</span></span><br><span class="line">CPUID<span class="comment">//  CPUID 会设置 AX ， BX ， CX ， DX 的值</span></span><br><span class="line">MOVLAX, SI<span class="comment">//  SI = AX ， 保存 CPU 信息</span></span><br><span class="line">CMPLAX, $<span class="number">0</span><span class="comment">// 如果没有获取到</span></span><br><span class="line">JEnocpuinfo<span class="comment">// 跳转到 nocpuinfo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Figure out how to serialize RDTSC.</span></span><br><span class="line"><span class="comment">// On Intel processors LFENCE is enough. AMD requires MFENCE.</span></span><br><span class="line"><span class="comment">// Don't know about the rest, so let's do MFENCE.</span></span><br><span class="line"><span class="comment">//  处理如何序列化 RDTSC 。在 intel 处理器上， LFENCE 足够了。 AMD 则需要 MFENCE。 其他处理器的情况不清楚，所以让用 MFENCE。</span></span><br><span class="line"><span class="comment">// 判断是否是 intel cpu</span></span><br><span class="line">CMPLBX, $<span class="number">0x756E6547</span>  <span class="comment">// "Genu"</span></span><br><span class="line">JNEnotintel</span><br><span class="line">CMPLDX, $<span class="number">0x49656E69</span>  <span class="comment">// "ineI"</span></span><br><span class="line">JNEnotintel</span><br><span class="line">CMPLCX, $<span class="number">0x6C65746E</span>  <span class="comment">// "ntel"</span></span><br><span class="line">JNEnotintel</span><br><span class="line">MOVB$<span class="number">1</span>, runtime·isIntel(SB)<span class="comment">// 设置是否是 intel cpu ，在 proc.go 中。</span></span><br><span class="line">MOVB$<span class="number">1</span>, runtime·lfenceBeforeRdtsc(SB)<span class="comment">// 设置是否在 RDTSC 指令之前是否需要 LFENCE 指令。否则是 MFENCE 指令。</span></span><br><span class="line">notintel:</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load EAX=1 cpuid flags</span></span><br><span class="line">MOVL$<span class="number">1</span>, AX<span class="comment">//  AX = 1 ，CPUID 参数？</span></span><br><span class="line">CPUID<span class="comment">//  获取 cpu flags</span></span><br><span class="line">MOVLAX, runtime·processorVersionInfo(SB)<span class="comment">// 设置 processorVersionInfo</span></span><br><span class="line"></span><br><span class="line">nocpuinfo:</span><br><span class="line"><span class="comment">// if there is an _cgo_init, call it.</span></span><br><span class="line"><span class="comment">// 如果有 _cgo_init ，就执行</span></span><br><span class="line">MOVQ_cgo_init(SB), AX</span><br><span class="line"><span class="comment">//  TEST 对两个参数(目标，源)执行 AND 逻辑操作，并根据结果设置标志寄存器 (ZF)，结果本身不会保存。</span></span><br><span class="line"><span class="comment">//  ZF(Zero Flag) 零标志，运算结果为0时置1，否则置0。</span></span><br><span class="line">TESTQAX, AX</span><br><span class="line">JZneedtls <span class="comment">// jump if zero，也就是 AX AND AX == 0 （ _cgo_init 返回 0 ），则跳转到 needtls</span></span><br><span class="line"><span class="comment">// g0 already in DI</span></span><br><span class="line"><span class="comment">// 这里的 DI 就是上面初始化 g0 时设置的 g0 的地址</span></span><br><span class="line">MOVQDI, CX<span class="comment">// Win64 uses CX for first parameter</span></span><br><span class="line">MOVQ$setg_gcc&lt;&gt;(SB), SI</span><br><span class="line">CALLAX</span><br><span class="line"></span><br><span class="line"><span class="comment">// update stackguard after _cgo_init</span></span><br><span class="line"><span class="comment">// _cgo_init 后更新 stackguard</span></span><br><span class="line">MOVQ$runtime·g0(SB), CX<span class="comment">//  CX = g0</span></span><br><span class="line">MOVQ(g_stack+stack_lo)(CX), AX<span class="comment">//  AX = g0.stack.lo</span></span><br><span class="line">ADDQ$const__StackGuard, AX<span class="comment">//  AX += const__StackGuard , stack.go 中定义</span></span><br><span class="line">MOVQAX, g_stackguard0(CX)<span class="comment">//  g0.stackguard0 = AX = g0.stack.lo + const__StackGuard</span></span><br><span class="line">MOVQAX, g_stackguard1(CX)<span class="comment">//  g0.stackguard1 = AX = g0.stack.lo + const__StackGuard</span></span><br><span class="line"></span><br><span class="line">#ifndef GOOS_windows</span><br><span class="line">JMP ok<span class="comment">//  Windows 跳转到 ok</span></span><br><span class="line">#endif</span><br><span class="line">needtls:</span><br><span class="line">#ifdef GOOS_plan9</span><br><span class="line"><span class="comment">// skip TLS setup on Plan 9</span></span><br><span class="line">JMP ok<span class="comment">//  Plan 9 跳转到 ok</span></span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_solaris</span><br><span class="line"><span class="comment">// skip TLS setup on Solaris</span></span><br><span class="line">JMP ok<span class="comment">//  GOOS_solaris 跳转到 ok</span></span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_darwin</span><br><span class="line"><span class="comment">// skip TLS setup on Darwin</span></span><br><span class="line">JMP ok<span class="comment">//  GOOS_darwin 跳转到 ok</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置tls， Thread Local Storage</span></span><br><span class="line">LEAQruntime·m0+m_tls(SB), DI<span class="comment">//  DI = m0.tls ，这个会在 runtime·settls 中使用</span></span><br><span class="line">CALLruntime·settls(SB)<span class="comment">// 调用 runtime·settls, settls 函数的参数在DI寄存器中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// store through it, to make sure it works</span></span><br><span class="line"><span class="comment">// get_tls 和 g 是宏，位于 runtime/go_tls.h</span></span><br><span class="line"><span class="comment">// #defineget_tls(r)MOVQ TLS, r</span></span><br><span class="line"><span class="comment">// #defineg(r)0(r)(TLS*1)</span></span><br><span class="line"><span class="comment">// 此处对 tls 进行了一次测试，确保值正确写入了 m0.tls</span></span><br><span class="line">get_tls(BX)<span class="comment">// 等价于 MOVQ TLS, BX 。 从 TLS 起始移动 8 byte 值到 BX 寄存器，获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址</span></span><br><span class="line">MOVQ$<span class="number">0x123</span>, g(BX)<span class="comment">//  0(BX)(TLS*1) = $0x123 ，0x123拷贝到fs段基地址偏移-8的内存位置，也就是m0.tls[0] =0x123</span></span><br><span class="line">MOVQruntime·m0+m_tls(SB), AX<span class="comment">//  AX = m0.tls[0]</span></span><br><span class="line">CMPQAX, $<span class="number">0x123</span><span class="comment">// 比较 AX == $0x123</span></span><br><span class="line">JEQ <span class="number">2</span>(PC)<span class="comment">// 如果相等，跳转下面 2 条指令，也就是 ok 后</span></span><br><span class="line">CALLruntime·abort(SB)<span class="comment">// 检测失败</span></span><br><span class="line">ok:</span><br><span class="line"><span class="comment">// set the per-goroutine and per-mach "registers"</span></span><br><span class="line"><span class="comment">// 将 g0 放到 tls 里，这里实际上就是 m0.tls</span></span><br><span class="line">get_tls(BX)<span class="comment">// 等价于 MOVQ TLS, BX 。 从 TLS 起始移动 8 byte 值到 BX 寄存器，获取 fs 段基地址并放入 BX 寄存器，其实就是 m0.tls[1] 的地址</span></span><br><span class="line">LEAQruntime·g0(SB), CX<span class="comment">// CX=g0</span></span><br><span class="line">MOVQCX, g(BX)<span class="comment">// 等价于 MOVQ CX， 0(BX)(TLS*1),  把g0存到TLS</span></span><br><span class="line">LEAQruntime·m0(SB), AX<span class="comment">// AX=m0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">MOVQCX, m_g0(AX)<span class="comment">// m0.g0 = g0</span></span><br><span class="line"><span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">MOVQAX, g_m(CX)<span class="comment">// g0.m = m0</span></span><br><span class="line"></span><br><span class="line">CLD<span class="comment">// convention is D is always left cleared</span></span><br><span class="line"><span class="comment">// 这个函数检查了各种类型以及类型转换是否有问题</span></span><br><span class="line">CALLruntime·check(SB)</span><br><span class="line"></span><br><span class="line">MOVL<span class="number">16</span>(SP), AX<span class="comment">// copy argc//  AX = argc</span></span><br><span class="line">MOVLAX, <span class="number">0</span>(SP)<span class="comment">// 设置后面 runtime·args 调用的第一个参数</span></span><br><span class="line">MOVQ<span class="number">24</span>(SP), AX<span class="comment">// copy argv//  AX = argv</span></span><br><span class="line">MOVQAX, <span class="number">8</span>(SP)<span class="comment">// 设置后面 runtime·args 调用的第二个参数</span></span><br><span class="line">CALLruntime·args(SB)<span class="comment">// 设置参数 ， 函数原型： func args(c int32, v **byte) ， 在 runtime1.go</span></span><br><span class="line">CALLruntime·osinit(SB)<span class="comment">// 初始化 os ，在 os_linux.go</span></span><br><span class="line">CALLruntime·schedinit(SB)<span class="comment">// 初始化 sched ，在 proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line"><span class="comment">// 创建 goroutine 并加入到等待队列，该 goroutine 执行 runtime.mainPC 所指向的函数</span></span><br><span class="line">MOVQ$runtime·mainPC(SB), AX<span class="comment">// entry//  入口函数 在 proc.go 中</span></span><br><span class="line">PUSHQAX<span class="comment">// 压栈，设置参数 runtime·newproc 的 fn</span></span><br><span class="line">PUSHQ$<span class="number">0</span><span class="comment">// arg size// 压栈，设置参数 runtime·newproc 的 siz</span></span><br><span class="line">CALLruntime·newproc(SB)<span class="comment">// 调用 runtime·newproc ，在 proc.go 函数原型： func newproc(siz int32, fn *funcval)</span></span><br><span class="line">POPQAX<span class="comment">// 弹出 PUSHQ$0</span></span><br><span class="line">POPQAX<span class="comment">// 弹出 PUSHQAX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start this M</span></span><br><span class="line">CALLruntime·mstart(SB)<span class="comment">// 启动调度程序，调度到刚刚创建的 goroutine 执行，在 proc.go 函数原型： func mstart()</span></span><br><span class="line"></span><br><span class="line">CALLruntime·abort(SB)<span class="comment">// mstart should never return //  mstart 永远不会返回</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent dead-code elimination of debugCallV1, which is</span></span><br><span class="line"><span class="comment">// intended to be called by debuggers.</span></span><br><span class="line"><span class="comment">// 防止调试程序要调用的 debugCallV1 消除死代码。</span></span><br><span class="line">MOVQ$runtime·debugCallV1(SB), AX<span class="comment">// AX = runtime·debugCallV1</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明全局的变量 mainPC 为 runtime.main 函数的地址，该变量为 read only</span></span><br><span class="line">DATAruntime·mainPC+<span class="number">0</span>(SB)/<span class="number">8</span>,$runtime·main(SB)</span><br><span class="line">GLOBLruntime·mainPC(SB),RODATA,$<span class="number">8</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 在上面我们看到会调用runtime·check, runtime·args, runtime·osinit， runtime·schedinit， runtime·mainPC， runtime·newproc， runtime·mstart， runtime·abort 等等几个函数， 这些就是Go启动的重要函数。</p><p>&emsp;&emsp; 从上面可以看到会调用到<code>runtime.mainPC</code>， 而<code>runtime.mainPC</code>即是runtime·main的地址， 那么最终就会调用到runtime·main， 我们查看runtime.main（在go/src/runtime/proc.go中）的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main goroutine.</span></span><br><span class="line"><span class="comment">//  主 goroutine，也就是runtime·mainPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取当前的G, G为TLS(Thread Local Storage)</span></span><br><span class="line">g := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.</span></span><br><span class="line"><span class="comment">// It must not be used for anything else.</span></span><br><span class="line"><span class="comment">//  m0-&gt;g0  的racectx仅用作主 goroutine的父代。不得将其用于其他任何用途。</span></span><br><span class="line">g.m.g0.racectx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</span></span><br><span class="line"><span class="comment">// Using decimal instead of binary GB and MB because</span></span><br><span class="line"><span class="comment">// they look nicer in the stack overflow failure message.</span></span><br><span class="line"><span class="comment">// 执行栈的最大限制： 1GB on 64-bit， 250 MB on 32-bit。使用十进制而不是二进制GB和MB，因为它们在堆栈溢出失败消息中好看些。</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">maxstacksize = <span class="number">1000000000</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxstacksize = <span class="number">250000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line"><span class="comment">// 标示main goroutine启动了，接下来允许 newproc 启动新的 m</span></span><br><span class="line">mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon // 1.11 新引入的 web assembly, 目前 wasm 不支持线程，无系统监控</span></span><br><span class="line"><span class="comment">// 启动系统后台监控 (定期 GC，并发任务调度)</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock the main goroutine onto this, the main OS thread,</span></span><br><span class="line"><span class="comment">// during initialization. Most programs won't care, but a few</span></span><br><span class="line"><span class="comment">// do require certain calls to be made by the main thread.</span></span><br><span class="line"><span class="comment">// Those can arrange for main.main to run in the main thread</span></span><br><span class="line"><span class="comment">// by calling runtime.LockOSThread during initialization</span></span><br><span class="line"><span class="comment">// to preserve the lock.</span></span><br><span class="line"><span class="comment">// 将主 goroutine 锁在主 OS 线程下进行初始化工作。大部分程序并不关心这一点，但是有一些图形库（基本上属于 cgo 调用）会要求在主线程下进行初始化工作。</span></span><br><span class="line"><span class="comment">// 即便是在 main.main 下仍然可以通过公共方法 runtime.LockOSThread 来强制将一些特殊的需要主 OS 线程的调用锁在主 OS 线程下执行初始化</span></span><br><span class="line">lockOSThread()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 runtime.main 函数的 G 必须是绑定在 m0 上的</span></span><br><span class="line"><span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">throw(<span class="string">"runtime.main not on m0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  执行初始化运行时</span></span><br><span class="line">runtime_init() <span class="comment">// must be before defer //  defer 必须在此调用结束后才能使用</span></span><br><span class="line"><span class="keyword">if</span> nanotime() == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"nanotime returning zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Defer unlock so that runtime.Goexit during init does the unlock too.</span></span><br><span class="line"><span class="comment">// 延迟解锁，以便init期间的runtime.Goexit也会执行解锁。</span></span><br><span class="line">needUnlock := <span class="literal">true</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> needUnlock &#123;</span><br><span class="line">unlockOSThread()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record when the world started.</span></span><br><span class="line"><span class="comment">// 记录程序的启动时间</span></span><br><span class="line">runtimeInitTime = nanotime()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动垃圾回收器后台操作</span></span><br><span class="line">gcenable()</span><br><span class="line"></span><br><span class="line">main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">if</span> iscgo &#123;</span><br><span class="line"><span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"_cgo_thread_start missing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> GOOS != <span class="string">"windows"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _cgo_setenv == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"_cgo_setenv missing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _cgo_unsetenv == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"_cgo_unsetenv missing"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _cgo_notify_runtime_init_done == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"_cgo_notify_runtime_init_done missing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Start the template thread in case we enter Go from</span></span><br><span class="line"><span class="comment">// a C-created thread and need to create a new thread.</span></span><br><span class="line"><span class="comment">// 启动模板线程来处理从 C 创建的线程进入 Go 时需要创建一个新的线程的情况。</span></span><br><span class="line">startTemplateThread()</span><br><span class="line">cgocall(_cgo_notify_runtime_init_done, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 main_init，进行间接调用，因为链接器在设定运行时的时候不知道 main 包的地址</span></span><br><span class="line">fn := main_init <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">needUnlock = <span class="literal">false</span></span><br><span class="line">unlockOSThread()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是基础库则不需要执行 main 函数了</span></span><br><span class="line"><span class="keyword">if</span> isarchive || islibrary &#123;</span><br><span class="line"><span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line"><span class="comment">// has a main, but it is not executed.</span></span><br><span class="line"><span class="comment">// 使用-buildmode=c-archive或c-shared编译的程序具有main函数，但不会执行。</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行用户 main 包中的 main 函数，处理为非间接调用，因为链接器在设定运行时不知道 main 包的地址</span></span><br><span class="line">fn = main_main <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// race 相关</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racefini()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make racy client program work: if panicking on</span></span><br><span class="line"><span class="comment">// another goroutine at the same time as main returns,</span></span><br><span class="line"><span class="comment">// let the other goroutine finish printing the panic trace.</span></span><br><span class="line"><span class="comment">// Once it does, it will exit. See issues 3934 and 20018.\</span></span><br><span class="line"><span class="comment">// 使客户端程序正常工作：如果在其他 goroutine 上 panic 、与此同时 main 返回，也让其他 goroutine 能够完成 panic trace 的打印。打印完成后，立即退出。</span></span><br><span class="line"><span class="comment">// 见 issue 3934 和 20018</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Running deferred functions should not take long.</span></span><br><span class="line"><span class="comment">// 运行 defer 函数应该不会花太长时间。</span></span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">1000</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;runningPanicDefers) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;panicking) != <span class="number">0</span> &#123;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonPanicWait, traceEvGoStop, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出执行，返回退出状态码</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 exit 没有被正确实现，则下面的代码能够强制退出程序，因为 *nil (nil deref) 会崩溃。</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> x *<span class="keyword">int32</span></span><br><span class="line">*x = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来把其它几个函数看看：</p><ul><li>runtime·check(go/src/runtime/runtime1.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 做一些数据检测</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">a     <span class="keyword">int8</span></span><br><span class="line">b     <span class="keyword">uint8</span></span><br><span class="line">c     <span class="keyword">int16</span></span><br><span class="line">d     <span class="keyword">uint16</span></span><br><span class="line">e     <span class="keyword">int32</span></span><br><span class="line">f     <span class="keyword">uint32</span></span><br><span class="line">g     <span class="keyword">int64</span></span><br><span class="line">h     <span class="keyword">uint64</span></span><br><span class="line">i, i1 <span class="keyword">float32</span></span><br><span class="line">j, j1 <span class="keyword">float64</span></span><br><span class="line">k     unsafe.Pointer</span><br><span class="line">l     *<span class="keyword">uint16</span></span><br><span class="line">m     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> x1t <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> y1t <span class="keyword">struct</span> &#123;</span><br><span class="line">x1 x1t</span><br><span class="line">y  <span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x1 x1t</span><br><span class="line"><span class="keyword">var</span> y1 y1t</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(a) != <span class="number">1</span> &#123;</span><br><span class="line">throw(<span class="string">"bad a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(b) != <span class="number">1</span> &#123;</span><br><span class="line">throw(<span class="string">"bad b"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(c) != <span class="number">2</span> &#123;</span><br><span class="line">throw(<span class="string">"bad c"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(d) != <span class="number">2</span> &#123;</span><br><span class="line">throw(<span class="string">"bad d"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(e) != <span class="number">4</span> &#123;</span><br><span class="line">throw(<span class="string">"bad e"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(f) != <span class="number">4</span> &#123;</span><br><span class="line">throw(<span class="string">"bad f"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(g) != <span class="number">8</span> &#123;</span><br><span class="line">throw(<span class="string">"bad g"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(h) != <span class="number">8</span> &#123;</span><br><span class="line">throw(<span class="string">"bad h"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(i) != <span class="number">4</span> &#123;</span><br><span class="line">throw(<span class="string">"bad i"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(j) != <span class="number">8</span> &#123;</span><br><span class="line">throw(<span class="string">"bad j"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(k) != sys.PtrSize &#123;</span><br><span class="line">throw(<span class="string">"bad k"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(l) != sys.PtrSize &#123;</span><br><span class="line">throw(<span class="string">"bad l"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(x1) != <span class="number">1</span> &#123;</span><br><span class="line">throw(<span class="string">"bad unsafe.Sizeof x1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Offsetof(y1.y) != <span class="number">1</span> &#123;</span><br><span class="line">throw(<span class="string">"bad offsetof y1.y"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(y1) != <span class="number">2</span> &#123;</span><br><span class="line">throw(<span class="string">"bad unsafe.Sizeof y1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> timediv(<span class="number">12345</span>*<span class="number">1000000000</span>+<span class="number">54321</span>, <span class="number">1000000000</span>, &amp;e) != <span class="number">12345</span> || e != <span class="number">54321</span> &#123;</span><br><span class="line">throw(<span class="string">"bad timediv"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">uint32</span></span><br><span class="line">z = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;z, <span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">throw(<span class="string">"cas1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> z != <span class="number">2</span> &#123;</span><br><span class="line">throw(<span class="string">"cas2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z = <span class="number">4</span></span><br><span class="line"><span class="keyword">if</span> atomic.Cas(&amp;z, <span class="number">5</span>, <span class="number">6</span>) &#123;</span><br><span class="line">throw(<span class="string">"cas3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> z != <span class="number">4</span> &#123;</span><br><span class="line">throw(<span class="string">"cas4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z = <span class="number">0xffffffff</span></span><br><span class="line"><span class="keyword">if</span> !atomic.Cas(&amp;z, <span class="number">0xffffffff</span>, <span class="number">0xfffffffe</span>) &#123;</span><br><span class="line">throw(<span class="string">"cas5"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> z != <span class="number">0xfffffffe</span> &#123;</span><br><span class="line">throw(<span class="string">"cas6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m = [<span class="number">4</span>]<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">atomic.Or8(&amp;m[<span class="number">1</span>], <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">0</span>] != <span class="number">1</span> || m[<span class="number">1</span>] != <span class="number">0xf1</span> || m[<span class="number">2</span>] != <span class="number">1</span> || m[<span class="number">3</span>] != <span class="number">1</span> &#123;</span><br><span class="line">throw(<span class="string">"atomicor8"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m = [<span class="number">4</span>]<span class="keyword">byte</span>&#123;<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>&#125;</span><br><span class="line">atomic.And8(&amp;m[<span class="number">1</span>], <span class="number">0x1</span>)</span><br><span class="line"><span class="keyword">if</span> m[<span class="number">0</span>] != <span class="number">0xff</span> || m[<span class="number">1</span>] != <span class="number">0x1</span> || m[<span class="number">2</span>] != <span class="number">0xff</span> || m[<span class="number">3</span>] != <span class="number">0xff</span> &#123;</span><br><span class="line">throw(<span class="string">"atomicand8"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;j)) = ^<span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> j == j &#123;</span><br><span class="line">throw(<span class="string">"float64nan"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !(j != j) &#123;</span><br><span class="line">throw(<span class="string">"float64nan1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;j1)) = ^<span class="keyword">uint64</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> j == j1 &#123;</span><br><span class="line">throw(<span class="string">"float64nan2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !(j != j1) &#123;</span><br><span class="line">throw(<span class="string">"float64nan3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;i)) = ^<span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> i == i &#123;</span><br><span class="line">throw(<span class="string">"float32nan"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == i &#123;</span><br><span class="line">throw(<span class="string">"float32nan1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;i1)) = ^<span class="keyword">uint32</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> i == i1 &#123;</span><br><span class="line">throw(<span class="string">"float32nan2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i == i1 &#123;</span><br><span class="line">throw(<span class="string">"float32nan3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAtomic64()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _FixedStack != round2(_FixedStack) &#123;</span><br><span class="line">throw(<span class="string">"FixedStack is not power-of-2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !checkASM() &#123;</span><br><span class="line">throw(<span class="string">"assembly checks failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime·args(go/src/runtime/runtime1.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">args</span><span class="params">(c <span class="keyword">int32</span>, v **<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">argc = c</span><br><span class="line">argv = v</span><br><span class="line">sysargs(c, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime·osinit(go/src/runtime/os_linux.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化os， 根据不同的平台也不一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">osinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">ncpu = getproccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime.schedinit(go/src/runtime/proc.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//call osinit</span></span><br><span class="line"><span class="comment">//call schedinit</span></span><br><span class="line"><span class="comment">//make &amp; queue new G</span></span><br><span class="line"><span class="comment">//call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br><span class="line"><span class="comment">// 启动顺序</span></span><br><span class="line"><span class="comment">// 调用 osinit</span></span><br><span class="line"><span class="comment">// 调用 schedinit</span></span><br><span class="line"><span class="comment">// make &amp; queue new G</span></span><br><span class="line"><span class="comment">// 调用 runtime·mstart</span></span><br><span class="line"><span class="comment">// 创建 G 的调用 runtime·main.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 初始化sched, 核心部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// raceinit must be the first call to race detector.</span></span><br><span class="line"><span class="comment">// In particular, it must be done before mallocinit below calls racemapshadow.</span></span><br><span class="line"><span class="comment">// raceinit 是作为 race detector(探测器) ，必须是的首个调用，特别是：必须在 调用 mallocinit 函数之前，在 racemapshadow函数之后调用</span></span><br><span class="line"><span class="comment">// 获取当前 G</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大系统线程数量（即 M），参考标准库 runtime/debug.SetMaxThreads</span></span><br><span class="line">sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">tracebackinit()    <span class="comment">// 初始化 traceback</span></span><br><span class="line">moduledataverify() <span class="comment">// 模块数据验证，负责检查链接器符号，以确保所有结构体的正确性</span></span><br><span class="line">stackinit()        <span class="comment">// 栈初始化，复用管理链表</span></span><br><span class="line">mallocinit()       <span class="comment">// 内存分配器初始化</span></span><br><span class="line">mcommoninit(_g_.m) <span class="comment">// 初始化当前 M</span></span><br><span class="line">cpuinit()          <span class="comment">// must run before alginit // 必须在 alginit 之前运行</span></span><br><span class="line">alginit()          <span class="comment">// maps must not be used before this call //  maps 不能在此调用之前使用，从 CPU 指令集初始化散列算法</span></span><br><span class="line">modulesinit()      <span class="comment">// provides activeModules // 模块链接，提供 activeModules</span></span><br><span class="line">typelinksinit()    <span class="comment">// uses maps, activeModules // 使用 maps, activeModules</span></span><br><span class="line">itabsinit()        <span class="comment">// uses activeModules // 初始化 interface table，使用 activeModules</span></span><br><span class="line"></span><br><span class="line">msigsave(_g_.m) <span class="comment">// 设置signal mask</span></span><br><span class="line">initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">goargs()         <span class="comment">// 初始化命令行用户参数</span></span><br><span class="line">goenvs()         <span class="comment">// 初始化环境变量</span></span><br><span class="line">parsedebugvars() <span class="comment">// 初始化debug参数，处理 GODEBUG、GOTRACEBACK 调试相关的环境变量设置</span></span><br><span class="line">gcinit()         <span class="comment">// gc初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络的上次轮询时间</span></span><br><span class="line">sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line"><span class="comment">// 设置procs， 根据cpu核数和环境变量GOMAXPROCS， 优先环境变量</span></span><br><span class="line">procs := ncpu</span><br><span class="line"><span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">procs = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整 P 的数量，这时所有 P 均为新建的 P，因此不能返回有本地任务的 P</span></span><br><span class="line"><span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For cgocheck &gt; 1, we turn on the write barrier at all times</span></span><br><span class="line"><span class="comment">// and check all pointer writes. We can't do this until after</span></span><br><span class="line"><span class="comment">// procresize because the write barrier needs a P.</span></span><br><span class="line"><span class="comment">// 对于 cgocheck&gt;1 ，我们始终打开 write barrier 并检查所有指针写。 我们要等到 procresize 后才能执行此操作，因为写障碍需要一个P。</span></span><br><span class="line"><span class="keyword">if</span> debug.cgocheck &gt; <span class="number">1</span> &#123;</span><br><span class="line">writeBarrier.cgo = <span class="literal">true</span></span><br><span class="line">writeBarrier.enabled = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">p.wbBuf.reset()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buildVersion == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Condition should never trigger. This code just serves</span></span><br><span class="line"><span class="comment">// to ensure runtime·buildVersion is kept in the resulting binary.</span></span><br><span class="line"><span class="comment">// 该条件永远不会被触发，此处只是为了防止 buildVersion 被编译器优化移除掉。</span></span><br><span class="line">buildVersion = <span class="string">"unknown"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime.newproc(go/src/runtime/proc.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new g running fn with siz bytes of arguments.</span></span><br><span class="line"><span class="comment">// Put it on the queue of g's waiting to run.</span></span><br><span class="line"><span class="comment">// The compiler turns a go statement into a call to this.</span></span><br><span class="line"><span class="comment">// Cannot split the stack because it assumes that the arguments</span></span><br><span class="line"><span class="comment">// are available sequentially after &amp;fn; they would not be</span></span><br><span class="line"><span class="comment">// copied if a stack split occurred.</span></span><br><span class="line">/<span class="keyword">go</span>:nosplit</span><br><span class="line"><span class="comment">// 创建 G 运行 fn , 参数大小为 siz 。把 G 放到等待队列。编译器会将 go 语句转化为该调用。</span></span><br><span class="line"><span class="comment">// 这时不能将栈进行分段，因为它假设了参数在 &amp;fn 之后顺序有效；如果 stack 进行了分段则他们不无法被拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line"><span class="comment">//  add 是一个指针运算，跳过函数指针，把栈上的参数起始地址找到，见 runtime2.go 中的 funcval 类型</span></span><br><span class="line">argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 获取调用方 PC 寄存器值</span></span><br><span class="line">pc := getcallerpc()</span><br><span class="line"><span class="comment">// 用 g0 系统栈创建 goroutine 对象。传递的参数包括 fn 函数入口地址, argp 参数起始地址, siz 参数长度, gp(g0)，调用方 pc(goroutine)</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class="line"><span class="comment">// at argp. callerpc is the address of the go statement that created</span></span><br><span class="line"><span class="comment">// this. The new g is put on the queue of g's waiting to run.</span></span><br><span class="line"><span class="comment">// 创建一个运行 fn 的新 g，具有 narg 字节大小的参数，从 argp 开始。callerps 是 go 语句的起始地址。新创建的 g 会被放入 g 的队列中等待运行。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 因为是在系统栈运行所以此时的 g 为 g0</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断下 func 的实现是否为空</span></span><br><span class="line"><span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 g 对应的 m 的 locks++, 禁止抢占，因为它可以在一个局部变量中保存 p</span></span><br><span class="line">_g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">siz := narg</span><br><span class="line">siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span> <span class="comment">// 字节对齐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line"><span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line"><span class="comment">// 4*sizeof(uintreg): extra space added below</span></span><br><span class="line"><span class="comment">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line"><span class="comment">// 必要时，可以分配并初始化一个更大的栈。</span></span><br><span class="line"><span class="comment">// 不值得：这几乎总是一个错误。</span></span><br><span class="line"><span class="comment">// 4*sizeof(uintreg): 在下方增加的额外空间</span></span><br><span class="line"><span class="comment">// sizeof(uintreg): 调用者 LR (arm) 返回的地址 (x86 在 gostartcall 中)</span></span><br><span class="line"><span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">throw(<span class="string">"newproc: function arguments too large for new goroutine"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 p</span></span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line"><span class="comment">// 从 g 空闲列表中，根据 p 获得一个新的 g</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化阶段，gfget 是不可能找到 g 的，也可能运行中本来就已经耗尽了</span></span><br><span class="line"><span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个拥有 _StackMin 大小的栈的 g</span></span><br><span class="line">newg = malg(_StackMin)</span><br><span class="line"><span class="comment">// 将新创建的 g 从 _Gidle 更新为 _Gdead 状态</span></span><br><span class="line">casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line"><span class="comment">// 将 Gdead 状态的 g 添加到 allg，这样 GC 不会扫描未初始化的栈</span></span><br><span class="line">allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查新 g 的执行栈</span></span><br><span class="line"><span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"newproc1: newg missing stack"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论是取到的 g 还是新创建的 g，都应该是 _Gdead 状态</span></span><br><span class="line"><span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">throw(<span class="string">"newproc1: new g is not Gdead"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算运行空间大小，与 spAlign 对齐</span></span><br><span class="line">totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line"><span class="comment">// 确定 sp 和参数入栈位置</span></span><br><span class="line">sp := newg.stack.hi - totalSize</span><br><span class="line">spArg := sp</span><br><span class="line"><span class="comment">// arm</span></span><br><span class="line"><span class="keyword">if</span> usesLR &#123;</span><br><span class="line"><span class="comment">// caller's LR</span></span><br><span class="line"><span class="comment">// 调用方的 LR 寄存器</span></span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">prepGoExitFrame(sp)</span><br><span class="line">spArg += sys.MinFrameSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理参数，当有参数时，将参数拷贝到 goroutine 的执行栈中</span></span><br><span class="line"><span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 从 argp 参数开始的位置，复制 narg 个字节到 spArg（参数拷贝）</span></span><br><span class="line">memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line"><span class="comment">// This is a stack-to-stack copy. If write barriers</span></span><br><span class="line"><span class="comment">// are enabled and the source stack is grey (the</span></span><br><span class="line"><span class="comment">// destination is always black), then perform a</span></span><br><span class="line"><span class="comment">// barrier copy. We do this *after* the memmove</span></span><br><span class="line"><span class="comment">// because the destination stack may have garbage on</span></span><br><span class="line"><span class="comment">// it.</span></span><br><span class="line"><span class="comment">// 栈到栈的拷贝。如果启用了 write barrier 并且 源栈为灰色（目标始终为黑色），则执行 barrier 拷贝。因为目标栈上可能有垃圾，我们在 memmove 之后执行此操作。</span></span><br><span class="line"><span class="comment">// 如果需要 write barrier 并且 gc scan 未结束，</span></span><br><span class="line"><span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">f := findfunc(fn.fn)</span><br><span class="line">stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line"><span class="keyword">if</span> stkmap.nbit &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class="line"><span class="comment">// 我们正位于 prologue (序言) 部分，因此栈 map 索引总是 0</span></span><br><span class="line">bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// bulkBarrierBitmap执行写入障碍</span></span><br><span class="line">bulkBarrierBitmap(spArg, spArg, <span class="keyword">uintptr</span>(bv.n)*sys.PtrSize, <span class="number">0</span>, bv.bytedata)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理、创建并初始化的 g 的运行现场</span></span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">newg.sched.sp = sp</span><br><span class="line">newg.stktopsp = sp</span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function // +PCQuantum 从而前一个指令还在相同的函数内</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 g 的基本状态</span></span><br><span class="line">newg.gopc = callerpc</span><br><span class="line">newg.ancestors = saveAncestors(callergp) <span class="comment">// 调试相关，追踪调用方</span></span><br><span class="line">newg.startpc = fn.fn                     <span class="comment">// 如果 PC</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 设置 profiler 标签</span></span><br><span class="line">newg.labels = _g_.m.curg.labels</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计 sched.ngsys</span></span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 将 g 更换为 _Grunnable 状态</span></span><br><span class="line">casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配 goid</span></span><br><span class="line"><span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line"><span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line"><span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line"><span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line"><span class="comment">//   Sched.goidgen 为最后一个分配的 id，这一批必须为 [sched.goidgen+1, sched.goidgen+GoidCacheBatch]。启动时 sched.goidgen=0, 因此主 goroutine 的 goid 为 1</span></span><br><span class="line"><span class="comment">// 一次分配多个 _GoidCacheBatch(16) 个ID</span></span><br><span class="line">_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">&#125;</span><br><span class="line">newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">_p_.goidcache++</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">newg.racectx = racegostart(callerpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trace 相关</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoCreate(newg, newg.startpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将这里新创建的 g 放入 p 的本地队列或直接放入全局队列，true 表示放入执行队列的下一个，false 表示放入队尾</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有空闲的 P、且 spinning 的 M 数量为 0，且主 goroutine 已经开始运行，则进行唤醒 p 。初始化阶段 mainStarted 为 false，所以 p 不会被唤醒</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack // 在 newstack 中清除了抢占请求的情况下恢复抢占请求</span></span><br><span class="line">_g_.stackguard0 = stackPreempt</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime.mstart(go/src/runtime/proc.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called to start an M.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must not split the stack because we may not even have stack</span></span><br><span class="line"><span class="comment">// bounds set up yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run during STW (because it doesn't have a P yet), so write</span></span><br><span class="line"><span class="comment">// barriers are not allowed.</span></span><br><span class="line"><span class="comment">// 启动 M ， M 的入口函数</span></span><br><span class="line"><span class="comment">// 该函数不允许分段栈，因为我们甚至还没有设置栈的边界。它可能会在 STW 阶段运行（因为它还没有 P），所以 write barrier 也是不允许的</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">/<span class="keyword">go</span>:nosplit</span><br><span class="line">/<span class="keyword">go</span>:nowritebarrierrec</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定执行栈的边界。通过检查 g 执行占的边界来确定是否为系统栈</span></span><br><span class="line">osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> osStack &#123;</span><br><span class="line"><span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line"><span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line"><span class="comment">// minit may update the stack bounds.</span></span><br><span class="line"><span class="comment">// 根据系统栈初始化执行栈的边界。cgo 可能会离开 stack.hi 。minit 可能会更新栈的边界</span></span><br><span class="line">size := _g_.stack.hi</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">&#125;</span><br><span class="line">_g_.stack.hi = <span class="keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initialize stack guards so that we can start calling</span></span><br><span class="line"><span class="comment">// both Go and C functions with stack growth prologues.</span></span><br><span class="line"><span class="comment">// 初始化堆栈守卫，以便我们可以使用堆栈增长 prologue (序言) 开始调用Go和C函数。</span></span><br><span class="line">_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">_g_.stackguard1 = _g_.stackguard0</span><br><span class="line"><span class="comment">// 启动 M</span></span><br><span class="line">mstart1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit this thread.</span></span><br><span class="line"><span class="comment">// 退出线程</span></span><br><span class="line"><span class="keyword">if</span> GOOS == <span class="string">"windows"</span> || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"plan9"</span> || GOOS == <span class="string">"darwin"</span> || GOOS == <span class="string">"aix"</span> &#123;</span><br><span class="line"><span class="comment">// Window, Solaris, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line"><span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line"><span class="comment">// so the logic above hasn't set osStack yet.</span></span><br><span class="line"><span class="comment">// Window，Solaris，Darwin，AIX和Plan 9始终对栈进行系统分配，但将其放在mstart之前的_g_.stack中，因此上述逻辑尚未设置osStack。</span></span><br><span class="line">osStack = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出线程</span></span><br><span class="line">mexit(osStack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前执行的 g 是不是 g0</span></span><br><span class="line"><span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">throw(<span class="string">"bad runtime·mstart"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the caller for use as the top of stack in mcall and</span></span><br><span class="line"><span class="comment">// for terminating the thread.</span></span><br><span class="line"><span class="comment">// We're never coming back to mstart1 after we call schedule,</span></span><br><span class="line"><span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line"><span class="comment">// 这里会记录前一个调用者的状态， 包含 PC , SP 以及其他信息。这份记录会当作最初栈 (top stack)，给之后的 mcall 调用，也用来结束那个线程。</span></span><br><span class="line"><span class="comment">// 接下來在 mstart1 调用到 schedule 之后就再也不会回到这个地方了，所以其他调用可以重用当前帧。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助编译器的帮助获取 PC 和 SP , 然后在 save 中更新当前 G 的 sched (type gobuf) 的一些成员， 保存调用者的 pc 和 sp ，让日后其他执行者执行 gogo 函数的时候使用。</span></span><br><span class="line">save(getcallerpc(), getcallersp())</span><br><span class="line">asminit() <span class="comment">// 初始化汇编，但是 amd64 架构下不需要执行任何代码就立刻返回，其他像是 arm、386 才有一些需在这里设定一些 CPU 相关的內容。</span></span><br><span class="line">minit()   <span class="comment">// 初始化m 包括信号栈和信号掩码，procid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line"><span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line"><span class="comment">// 设置信号 handler ；在 minit 之后，因为 minit 可以准备处理信号的的线程</span></span><br><span class="line"><span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line"><span class="comment">// 在当前的 goroutine 的所属执行者是 m0 的情況下进入 mstartm0 函数，正式启动在此之前的 signal 处理设定，其中最关键的是 initsig 函数。</span></span><br><span class="line">mstartm0()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行启动函数</span></span><br><span class="line"><span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 m 并非 m0，则要求绑定 p</span></span><br><span class="line"><span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 彻底准备好，开始调度，永不返回</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runtime·abort(go/src/runtime/stubs.go)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abort crashes the runtime in situations where even throw might not</span></span><br><span class="line"><span class="comment">// work. In general it should do something a debugger will recognize</span></span><br><span class="line"><span class="comment">// (e.g., an INT3 on x86). A crash in abort is recognized by the</span></span><br><span class="line"><span class="comment">// signal handler, which will attempt to tear down the runtime</span></span><br><span class="line"><span class="comment">// immediately.</span></span><br><span class="line"><span class="comment">// 在抛出异常甚至都不起作用的情况下，abort会使运行时崩溃。通常，它应该执行调试程序可以识别的操作（例如，x86上的INT3）。</span></span><br><span class="line"><span class="comment">// 信号处理程序会识别中止中的崩溃，这将尝试立即中断运行时。 INT 3</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abort</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>在汇编中实现（go/src/runtime/asm_amd64.s）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·abort(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">INT$<span class="number">3</span></span><br><span class="line">loop:</span><br><span class="line">JMPloop</span><br></pre></td></tr></table></figure><h2 id="查看断点情况"><a href="#查看断点情况" class="headerlink" title="查看断点情况"></a>查看断点情况</h2><p>&emsp;&emsp;等运行完后， 查看断点情况如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000452890 in _rt0_amd64_linux at go/src/runtime/rt0_linux_amd64.s:8</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x000000000044ef70 in _rt0_amd64 at go/src/runtime/asm_amd64.s:15</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x000000000044ef80 in runtime.rt0_go at go/src/runtime/asm_amd64.s:89</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">4       breakpoint     keep y   0x0000000000436750 in runtime.check at go/src/runtime/runtime1.go:136</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">5       breakpoint     keep y   0x00000000004361f0 in runtime.args at go/src/runtime/runtime1.go:60</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">6       breakpoint     keep y   0x00000000004264a0 in runtime.osinit at go/src/runtime/os_linux.go:277</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">7       breakpoint     keep y   0x000000000042a8b0 in runtime.schedinit at go/src/runtime/proc.go:526</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">8       breakpoint     keep y   0x00000000004310b0 in runtime.newproc at go/src/runtime/proc.go:3239</span><br><span class="line">        breakpoint already hit 4 times</span><br><span class="line">9       breakpoint     keep y   0x000000000042c4a0 in runtime.mstart at go/src/runtime/proc.go:1153</span><br><span class="line">        breakpoint already hit 5 times</span><br><span class="line">10      breakpoint     keep y   0x0000000000450a60 in runtime.abort at go/src/runtime/asm_amd64.s:837</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;很多人也许对Go代码是怎么启动的比较感兴趣， 我也不例外。 因此在这里调试下代码， 看看到底是怎么启动的， 并在此做下记录, 暂时不会逐行分析，只是了解下Go的启动流程。（关于环境，在第一篇&lt;a href=&quot;https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/#more&quot;&gt;【golang源码分析】之源码结构&lt;/a&gt;中已经提到过， 如无特殊说明后续相关的都是基于此环境，不再提及。）&lt;/p&gt;
    
    </summary>
    
      <category term="【golang源码分析】" scheme="https://veezhang.github.io/categories/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91/"/>
    
    
      <category term="golang" scheme="https://veezhang.github.io/tags/golang/"/>
    
      <category term="源码分析" scheme="https://veezhang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【golang源码分析】之源码结构</title>
    <link href="https://veezhang.github.io/2019/09/05/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E4%B9%8B%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://veezhang.github.io/2019/09/05/【golang源码分析】之源码结构/</id>
    <published>2019-09-05T12:23:50.000Z</published>
    <updated>2020-05-13T05:50:25.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要看golang源码"><a href="#为什么要看golang源码" class="headerlink" title="为什么要看golang源码"></a>为什么要看golang源码</h2><p>&emsp;&emsp;如果是为了简简单单的使用golang， 也许我们不需要去看golang源码。但是， 如果真的想在这方便有更深入的了解, 还是有必要去研究部分源码， 去深入了解原理， 这样在以后的编码中能够做到更高效； 另外，品读研习源码也能够很好的熟悉golang语法， 学习优质的代码编写。</p><a id="more"></a><h2 id="注释项目地址"><a href="#注释项目地址" class="headerlink" title="注释项目地址"></a>注释项目地址</h2><p>&emsp;&emsp;注释源码见： <a href="https://github.com/veezhang/go1.12.9-annotated" target="_blank" rel="noopener">cache2go-annotated</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>系统： Linux amd64</li><li>Go: 1.12.9</li></ul><h2 id="代码统计"><a href="#代码统计" class="headerlink" title="代码统计"></a>代码统计</h2><p>&emsp;&emsp;通过工具统计代码如下：</p><pre><code>github.com/AlDanial/cloc v 1.74  T=26.59 s (272.7 files/s, 80119.3 lines/s)-----------------------------------------------------------------------------------Language                         files          blank        comment           code-----------------------------------------------------------------------------------Go                                6422         154211         230199        1538978Assembly                           538          11929          17475         100852HTML                                50           6499            331          46892C                                  108           1216           1095           7910Perl                                15            355            369           2258JSON                                12              0              0           2061Bourne Shell                        13            155            645           1089Markdown                            13            271              0            825Bourne Again Shell                  26            192            307            802XML                                  4             85              9            623JavaScript                           5            101            153            612Python                               1            130            101            358C/C++ Header                        20             76            193            275DOS Batch                            5             52              1            241Protocol Buffers                     1              1              0            196CSS                                  3             51              9            176Windows Resource File                4             22              0            134RobotFramework                       1              0              0            106make                                 8             12             10             44Fortran 90                           2              1              3              8C++                                  1              3              5              7awk                                  1              1              6              7-----------------------------------------------------------------------------------SUM:                              7253         175363         250911        1704454-----------------------------------------------------------------------------------</code></pre><p>&emsp;&emsp;看起来代码有170w行，无从下手。但其没必要对每一个模块都去研习，也不需要逐行去研习。只需要去研习关键的模块，了解概念、结构、流程以及代码组织等等。 这样算下来， 其实代码量也不多。</p><h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h2><pre><code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── api                 # Go的api检查器 (<span class="keyword">go</span> tool api)</span><br><span class="line">├── doc                 # GoHTML格式的官方文档和说明</span><br><span class="line">├── lib                 #</span><br><span class="line">├── misc                #</span><br><span class="line">├── src                 # 源码</span><br><span class="line">│   ├── archive         # 归档， 实现了tar/zip</span><br><span class="line">│   ├── bufio           # 缓存IO</span><br><span class="line">│   ├── builtin         # <span class="keyword">go</span>内置预定义</span><br><span class="line">│   ├── bytes           # 实现了用于操作 []<span class="keyword">byte</span> 的函数</span><br><span class="line">│   ├── cmd             # <span class="keyword">go</span> 各种工具</span><br><span class="line">│   ├── compress        # 压缩／解压，实现了：bzip2、flate、gzip、lzw、zlib</span><br><span class="line">│   ├── container       # 容器数据结构，实现了: heap、list、ring</span><br><span class="line">│   ├── context         # Goroutine上下文</span><br><span class="line">│   ├── crypto          # 加密解密算法，实现了：aes、des、hmac、md5、rand、rsa、sha1、sha256、sha512等</span><br><span class="line">│   ├── database        # 提供了各种SQL或类SQL数据库的通用API</span><br><span class="line">│   ├── debug           # Go程序调试</span><br><span class="line">│   ├── encoding        # 编码，实现了：ascii85、asn1、base32、base64、binary、csv、gob、hex、json、pem、xml</span><br><span class="line">│   ├── errors          # 生成错误的函数， errors.New(text <span class="keyword">string</span>)</span><br><span class="line">│   ├── expvar          # 公共变量包（添加变量，可以监控），通过http在/debug/vars显示，包含命令行和内存信息</span><br><span class="line">│   ├── flag            # 处理命令参数</span><br><span class="line">│   ├── fmt             # 格式化</span><br><span class="line">│   ├── <span class="keyword">go</span>              # <span class="keyword">go</span></span><br><span class="line">│   ├── hash            # hash算法，实现了adler32、crc32、crc64、fnv</span><br><span class="line">│   ├── html            # template 实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出</span><br><span class="line">│   ├── image           # <span class="number">2</span>D图形</span><br><span class="line">│   ├── index           # suffixarray 后缀数组：使用内存后缀数组实现子串搜索</span><br><span class="line">│   ├── internal        # 内部包</span><br><span class="line">│   ├── io              # I/O 原语提供基本接口</span><br><span class="line">│   ├── log             # 日志</span><br><span class="line">│   ├── math            # 基本的常量和数学函数</span><br><span class="line">│   ├── mime            # 实现了MIME规范的一部分</span><br><span class="line">│   ├── net             # 网络I/O，包括TCP/IP，UDP，域名解析和Unix域套接字， http, mail, rpc, smtp, url 等</span><br><span class="line">│   ├── os              # 提供平台无关的OS接口</span><br><span class="line">│   ├── path            # 实现了针对操作斜线分割路径的实用例程</span><br><span class="line">│   ├── plugin          # 实现 Go 插件的加载和符号解析</span><br><span class="line">│   ├── reflect         # 实现运行时反射</span><br><span class="line">│   ├── regexp          # 正则表达式</span><br><span class="line">│   ├── runtime         # 包含与 Go 的运行时系统交互的操作</span><br><span class="line">│   ├── sort            # 排序</span><br><span class="line">│   ├── strconv         # 对基本数据类型的字符串表示的转换</span><br><span class="line">│   ├── strings         # 实现简单的函数来操纵 UTF<span class="number">-8</span> 编码的字符串</span><br><span class="line">│   ├── sync            # 提供基本的同步原语</span><br><span class="line">│   ├── syscall         # 系统调用</span><br><span class="line">│   ├── testing         # 测试</span><br><span class="line">│   ├── text            # 文本相关的接口</span><br><span class="line">│   ├── time            # 时间</span><br><span class="line">│   ├── unicode         # unicode实现</span><br><span class="line">│   └── unsafe          # 包含绕过Go程序类型安全的操作</span><br><span class="line">└── test                # Go语言自身代码的文件</span><br></pre></td></tr></table></figure></code></pre><p>&emsp;&emsp;这里的源码目录结构，会跟着理解的深入而逐步更新。</p><h2 id="给自己打气"><a href="#给自己打气" class="headerlink" title="给自己打气"></a>给自己打气</h2><p>&emsp;&emsp;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要看golang源码&quot;&gt;&lt;a href=&quot;#为什么要看golang源码&quot; class=&quot;headerlink&quot; title=&quot;为什么要看golang源码&quot;&gt;&lt;/a&gt;为什么要看golang源码&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;如果是为了简简单单的使用golang， 也许我们不需要去看golang源码。但是， 如果真的想在这方便有更深入的了解, 还是有必要去研究部分源码， 去深入了解原理， 这样在以后的编码中能够做到更高效； 另外，品读研习源码也能够很好的熟悉golang语法， 学习优质的代码编写。&lt;/p&gt;
    
    </summary>
    
      <category term="【golang源码分析】" scheme="https://veezhang.github.io/categories/%E3%80%90golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91/"/>
    
    
      <category term="golang" scheme="https://veezhang.github.io/tags/golang/"/>
    
      <category term="源码分析" scheme="https://veezhang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【cache2go源码分析】</title>
    <link href="https://veezhang.github.io/2019/09/03/%E3%80%90cache2go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91/"/>
    <id>https://veezhang.github.io/2019/09/03/【cache2go源码分析】/</id>
    <published>2019-09-03T15:23:25.000Z</published>
    <updated>2020-05-13T05:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cache2go是什么"><a href="#cache2go是什么" class="headerlink" title="cache2go是什么"></a><a href="https://github.com/muesli/cache2go" target="_blank" rel="noopener">cache2go</a>是什么</h2><p>&emsp;&emsp;在github上面的介绍是：Concurrency-safe golang caching library with expiration capabilities.意思是：　具有过期功能并发安全的go语言缓存库。</p><h2 id="注释项目地址"><a href="#注释项目地址" class="headerlink" title="注释项目地址"></a>注释项目地址</h2><p>&emsp;&emsp;注释源码见： <a href="https://github.com/veezhang/cache2go-annotated" target="_blank" rel="noopener">cache2go-annotated</a></p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">benchmark_test.<span class="keyword">go</span></span><br><span class="line">cache.<span class="keyword">go</span></span><br><span class="line">cacheitem.<span class="keyword">go</span></span><br><span class="line">cachetable.<span class="keyword">go</span></span><br><span class="line">cache_test.<span class="keyword">go</span></span><br><span class="line">errors.<span class="keyword">go</span></span><br><span class="line">examples</span><br><span class="line">LICENSE.txt</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>目录结构如上所示，主要功能实现源码文件为：　cache.go, cacheitem.go, cachetable.go. 接下来一一说明。</p><h2 id="源码注释"><a href="#源码注释" class="headerlink" title="源码注释"></a>源码注释</h2><ul><li><p>cacheitem.go</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Simple caching library with expiration capabilities</span></span><br><span class="line"><span class="comment">*     Copyright (c) 2013-2017, Christian Muehlhaeuser &lt;muesli@gmail.com&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   For license see LICENSE.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cache2go</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheItem is an individual cache item</span></span><br><span class="line"><span class="comment">// Parameter data contains the user-set value in the cache.</span></span><br><span class="line"><span class="comment">//  CacheItem是单个的缓存条目，　也就是一个key-value缓存数据</span></span><br><span class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//  读写锁，保证CacheItem同步访问</span></span><br><span class="line">    sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The item's key.</span></span><br><span class="line">    <span class="comment">//  key 可以是任意类型</span></span><br><span class="line">    key <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// The item's data.</span></span><br><span class="line">    <span class="comment">//  data 可以是任意类型</span></span><br><span class="line">    data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// How long will the item live in the cache when not being accessed/kept alive.</span></span><br><span class="line">    <span class="comment">//  不被访问后的保活时间</span></span><br><span class="line">    lifeSpan time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creation timestamp.</span></span><br><span class="line">    <span class="comment">//  创建的时间</span></span><br><span class="line">    createdOn time.Time</span><br><span class="line">    <span class="comment">// Last access timestamp.</span></span><br><span class="line">    <span class="comment">//  最近一次访问时间，KeepAlive函数修改</span></span><br><span class="line">    accessedOn time.Time</span><br><span class="line">    <span class="comment">// How often the item was accessed.</span></span><br><span class="line">    <span class="comment">//  访问的次数，KeepAlive函数修改</span></span><br><span class="line">    accessCount <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callback method triggered right before removing the item from the cache</span></span><br><span class="line">    <span class="comment">//  被移除时候的回调函数</span></span><br><span class="line">    aboutToExpire []<span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">NewCacheItem</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">newly</span> <span class="title">created</span> <span class="title">CacheItem</span>.</span></span><br><span class="line"><span class="function">// <span class="title">Parameter</span> <span class="title">key</span> <span class="title">is</span> <span class="title">the</span> <span class="title">item</span>'<span class="title">s</span> <span class="title">cache</span>-<span class="title">key</span>.</span></span><br><span class="line"><span class="function">// <span class="title">Parameter</span> <span class="title">lifeSpan</span> <span class="title">determines</span> <span class="title">after</span> <span class="title">which</span> <span class="title">time</span> <span class="title">period</span> <span class="title">without</span> <span class="title">an</span> <span class="title">access</span> <span class="title">the</span> <span class="title">item</span></span></span><br><span class="line"><span class="function">// <span class="title">will</span> <span class="title">get</span> <span class="title">removed</span> <span class="title">from</span> <span class="title">the</span> <span class="title">cache</span>.</span></span><br><span class="line"><span class="function">// <span class="title">Parameter</span> <span class="title">data</span> <span class="title">is</span> <span class="title">the</span> <span class="title">item</span>'<span class="title">s</span> <span class="title">value</span>.</span></span><br><span class="line"><span class="function">//  创建<span class="title">CacheItem</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewCacheItem</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="keyword">return</span> &amp;CacheItem&#123;</span><br><span class="line">        key:           key,</span><br><span class="line">        lifeSpan:      lifeSpan,</span><br><span class="line">        createdOn:     t,</span><br><span class="line">        accessedOn:    t,</span><br><span class="line">        accessCount:   <span class="number">0</span>,</span><br><span class="line">        aboutToExpire: <span class="literal">nil</span>,</span><br><span class="line">        data:          data,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeepAlive marks an item to be kept for another expireDuration period.</span></span><br><span class="line"><span class="comment">//  重置过期时间， 需要加锁（下面类似的不再说）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">KeepAlive</span><span class="params">()</span></span> &#123;</span><br><span class="line">    item.Lock()</span><br><span class="line">    <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">    item.accessedOn = time.Now()</span><br><span class="line">    item.accessCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LifeSpan returns this item's expiration duration.</span></span><br><span class="line"><span class="comment">//  返回lifeSpan， 不需要加锁， 因为创建后就没有情况会修改此值（下面类似的不再说）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">LifeSpan</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">return</span> item.lifeSpan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccessedOn returns when this item was last accessed.</span></span><br><span class="line"><span class="comment">//  返回accessedOn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AccessedOn</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    item.RLock()</span><br><span class="line">    <span class="keyword">defer</span> item.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> item.accessedOn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreatedOn returns when this item was added to the cache.</span></span><br><span class="line"><span class="comment">//  返回createdOn</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">CreatedOn</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">return</span> item.createdOn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccessCount returns how often this item has been accessed.</span></span><br><span class="line"><span class="comment">//  返回accessCount</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AccessCount</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    item.RLock()</span><br><span class="line">    <span class="keyword">defer</span> item.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> item.accessCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Key returns the key of this cached item.</span></span><br><span class="line"><span class="comment">//  返回key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">Key</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">return</span> item.key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data returns the value of this cached item.</span></span><br><span class="line"><span class="comment">//  返回data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">Data</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// immutable</span></span><br><span class="line">    <span class="keyword">return</span> item.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetAboutToExpireCallback configures a callback, which will be called right</span></span><br><span class="line"><span class="comment">// before the item is about to be removed from the cache.</span></span><br><span class="line"><span class="comment">//  设置被移除时候的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">SetAboutToExpireCallback</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(item.aboutToExpire) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        item.RemoveAboutToExpireCallback()</span><br><span class="line">    &#125;</span><br><span class="line">    item.Lock()</span><br><span class="line">    <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">    item.aboutToExpire = <span class="built_in">append</span>(item.aboutToExpire, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddAboutToExpireCallback appends a new callback to the AboutToExpire queue</span></span><br><span class="line"><span class="comment">//  添加被移除时候的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">AddAboutToExpireCallback</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">    item.Lock()</span><br><span class="line">    <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">    item.aboutToExpire = <span class="built_in">append</span>(item.aboutToExpire, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveAboutToExpireCallback empties the about to expire callback queue</span></span><br><span class="line"><span class="comment">//  删除被移除时候的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(item *CacheItem)</span> <span class="title">RemoveAboutToExpireCallback</span><span class="params">()</span></span> &#123;</span><br><span class="line">    item.Lock()</span><br><span class="line">    <span class="keyword">defer</span> item.Unlock()</span><br><span class="line">    item.aboutToExpire = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cachetable.go</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Simple caching library with expiration capabilities</span></span><br><span class="line"><span class="comment">*     Copyright (c) 2013-2017, Christian Muehlhaeuser &lt;muesli@gmail.com&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   For license see LICENSE.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cache2go</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheTable is a table within the cache</span></span><br><span class="line"><span class="comment">//  缓存表，</span></span><br><span class="line"><span class="keyword">type</span> CacheTable <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//  读写锁，保证CacheItem同步访问</span></span><br><span class="line">    sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The table's name.</span></span><br><span class="line">    <span class="comment">//  缓存表名称</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// All cached items.</span></span><br><span class="line">    <span class="comment">//  所有缓存的条目</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timer responsible for triggering cleanup.</span></span><br><span class="line">    <span class="comment">//  负责触发清除操作的计时器</span></span><br><span class="line">    cleanupTimer *time.Timer</span><br><span class="line">    <span class="comment">// Current timer duration.</span></span><br><span class="line">    <span class="comment">//  触发清理清除操作的时间间隔</span></span><br><span class="line">    cleanupInterval time.Duration</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The logger used for this table.</span></span><br><span class="line">    <span class="comment">//  日志</span></span><br><span class="line">    logger *log.Logger</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callback method triggered when trying to load a non-existing key.</span></span><br><span class="line">    <span class="comment">//  加载一个不存在的key时触发的回调函数</span></span><br><span class="line">    loadData <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span></span><br><span class="line"><span class="function">    // <span class="title">Callback</span> <span class="title">method</span> <span class="title">triggered</span> <span class="title">when</span> <span class="title">adding</span> <span class="title">a</span> <span class="title">new</span> <span class="title">item</span> <span class="title">to</span> <span class="title">the</span> <span class="title">cache</span>.</span></span><br><span class="line"><span class="function">    //  添加缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function">    <span class="title">addedItem</span> []<span class="title">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line"><span class="function">    // <span class="title">Callback</span> <span class="title">method</span> <span class="title">triggered</span> <span class="title">before</span> <span class="title">deleting</span> <span class="title">an</span> <span class="title">item</span> <span class="title">from</span> <span class="title">the</span> <span class="title">cache</span>.</span></span><br><span class="line"><span class="function">    //  删除缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function">    <span class="title">aboutToDeleteItem</span> []<span class="title">func</span><span class="params">(item *CacheItem)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Count</span> <span class="title">returns</span> <span class="title">how</span> <span class="title">many</span> <span class="title">items</span> <span class="title">are</span> <span class="title">currently</span> <span class="title">stored</span> <span class="title">in</span> <span class="title">the</span> <span class="title">cache</span>.</span></span><br><span class="line"><span class="function">//  返回缓存条目的数量</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    table.RLock()</span><br><span class="line">    <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(table.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Foreach all items</span></span><br><span class="line"><span class="comment">//  遍历缓存条目</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Foreach</span><span class="params">(trans <span class="keyword">func</span>(key <span class="keyword">interface</span>&#123;&#125;, item *CacheItem)</span>)</span> &#123;</span><br><span class="line">    table.RLock()</span><br><span class="line">    <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">        trans(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetDataLoader configures a data-loader callback, which will be called when</span></span><br><span class="line"><span class="comment">// trying to access a non-existing key. The key and 0...n additional arguments</span></span><br><span class="line"><span class="comment">// are passed to the callback function.</span></span><br><span class="line"><span class="comment">//  设置加载一个不存在的key时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetDataLoader</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;, ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span>)</span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.loadData = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetAddedItemCallback configures a callback, which will be called every time</span></span><br><span class="line"><span class="comment">// a new item is added to the cache.</span></span><br><span class="line"><span class="comment">//  设置添加缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetAddedItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(table.addedItem) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        table.RemoveAddedItemCallbacks()</span><br><span class="line">    &#125;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.addedItem = <span class="built_in">append</span>(table.addedItem, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AddAddedItemCallback appends a new callback to the addedItem queue</span></span><br><span class="line"><span class="comment">//  添加添加缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">AddAddedItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.addedItem = <span class="built_in">append</span>(table.addedItem, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveAddedItemCallbacks empties the added item callback queue</span></span><br><span class="line"><span class="comment">//  删除添加缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">RemoveAddedItemCallbacks</span><span class="params">()</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.addedItem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetAboutToDeleteItemCallback configures a callback, which will be called</span></span><br><span class="line"><span class="comment">// every time an item is about to be removed from the cache.</span></span><br><span class="line"><span class="comment">//  设置删除缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetAboutToDeleteItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(table.aboutToDeleteItem) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        table.RemoveAboutToDeleteItemCallback()</span><br><span class="line">    &#125;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.aboutToDeleteItem = <span class="built_in">append</span>(table.aboutToDeleteItem, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddAboutToDeleteItemCallback appends a new callback to the AboutToDeleteItem queue</span></span><br><span class="line"><span class="comment">//  添加删除缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">AddAboutToDeleteItemCallback</span><span class="params">(f <span class="keyword">func</span>(*CacheItem)</span>)</span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.aboutToDeleteItem = <span class="built_in">append</span>(table.aboutToDeleteItem, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveAboutToDeleteItemCallback empties the about to delete item callback queue</span></span><br><span class="line"><span class="comment">//  删除删除缓存条目时触发的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">RemoveAboutToDeleteItemCallback</span><span class="params">()</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.aboutToDeleteItem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetLogger sets the logger to be used by this cache table.</span></span><br><span class="line"><span class="comment">//  设置日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">SetLogger</span><span class="params">(logger *log.Logger)</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line">    table.logger = logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expiration check loop, triggered by a self-adjusting timer.</span></span><br><span class="line"><span class="comment">//  过期检查， 能自动调节间隔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">expirationCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="comment">//  计时器停止，后面调整间隔后启动</span></span><br><span class="line">    <span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">        table.cleanupTimer.Stop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> table.cleanupInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">        table.log(<span class="string">"Expiration check triggered after"</span>, table.cleanupInterval, <span class="string">"for table"</span>, table.name)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        table.log(<span class="string">"Expiration check installed for table"</span>, table.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To be more accurate with timers, we would need to update 'now' on every</span></span><br><span class="line">    <span class="comment">// loop iteration. Not sure it's really efficient though.</span></span><br><span class="line">    <span class="comment">//  每次会更新</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    <span class="comment">//  最小时间间隔</span></span><br><span class="line">    smallestDuration := <span class="number">0</span> * time.Second</span><br><span class="line">    <span class="comment">//  遍历所有的items查找最近一个将要过期的时间间隔</span></span><br><span class="line">    <span class="keyword">for</span> key, item := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">        <span class="comment">// Cache values so we don't keep blocking the mutex.</span></span><br><span class="line">        item.RLock()</span><br><span class="line">        lifeSpan := item.lifeSpan</span><br><span class="line">        accessedOn := item.accessedOn</span><br><span class="line">        item.RUnlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  0 表示永远不过期</span></span><br><span class="line">        <span class="keyword">if</span> lifeSpan == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  已经过期了，删除</span></span><br><span class="line">        <span class="keyword">if</span> now.Sub(accessedOn) &gt;= lifeSpan &#123;</span><br><span class="line">            <span class="comment">// Item has excessed its lifespan.</span></span><br><span class="line">            table.deleteInternal(key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Find the item chronologically closest to its end-of-lifespan.</span></span><br><span class="line">            <span class="comment">//  更新smallestDuration， 获取最近一个将要过期的时间间隔</span></span><br><span class="line">            <span class="keyword">if</span> smallestDuration == <span class="number">0</span> || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123;</span><br><span class="line">                smallestDuration = lifeSpan - now.Sub(accessedOn)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup the interval for the next cleanup run.</span></span><br><span class="line">    <span class="comment">// 设置cleanupInterval为最近将要过期的时间间隔</span></span><br><span class="line">    table.cleanupInterval = smallestDuration</span><br><span class="line">    <span class="keyword">if</span> smallestDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//  重新启动下一次的过期检测</span></span><br><span class="line">        table.cleanupTimer = time.AfterFunc(smallestDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">go</span> table.expirationCheck()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    table.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  内部添加函数， 代码重用， 调用这个方法之前需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">addInternal</span><span class="params">(item *CacheItem)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Careful: do not run this method unless the table-mutex is locked!</span></span><br><span class="line">    <span class="comment">// It will unlock it for the caller before running the callbacks and checks</span></span><br><span class="line">    table.log(<span class="string">"Adding item with key"</span>, item.key, <span class="string">"and lifespan of"</span>, item.lifeSpan, <span class="string">"to table"</span>, table.name)</span><br><span class="line">    table.items[item.key] = item</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache values so we don't keep blocking the mutex.</span></span><br><span class="line">    expDur := table.cleanupInterval</span><br><span class="line">    addedItem := table.addedItem</span><br><span class="line">    table.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger callback after adding an item to cache.</span></span><br><span class="line">    <span class="comment">// 触发增加条数的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> addedItem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, callback := <span class="keyword">range</span> addedItem &#123;</span><br><span class="line">            callback(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we haven't set up any expiration check timer or found a more imminent item.</span></span><br><span class="line">    <span class="comment">// 如果当前没有过期检测函数或者当前添加的比当前最短的过期时间还早过期，则更新过期检测</span></span><br><span class="line">    <span class="keyword">if</span> item.lifeSpan &gt; <span class="number">0</span> &amp;&amp; (expDur == <span class="number">0</span> || item.lifeSpan &lt; expDur) &#123;</span><br><span class="line">        table.expirationCheck()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds a key/value pair to the cache.</span></span><br><span class="line"><span class="comment">// Parameter key is the item's cache-key.</span></span><br><span class="line"><span class="comment">// Parameter lifeSpan determines after which time period without an access the item</span></span><br><span class="line"><span class="comment">// will get removed from the cache.</span></span><br><span class="line"><span class="comment">// Parameter data is the item's value.</span></span><br><span class="line"><span class="comment">//  添加缓存条目到缓存表中， addInternal会释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">    item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add item to cache.</span></span><br><span class="line">    table.Lock()</span><br><span class="line">    table.addInternal(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  内部删除函数， 代码重用， 调用这个方法之前需要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">deleteInternal</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">    r, ok := table.items[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache value so we don't keep blocking the mutex.</span></span><br><span class="line">    aboutToDeleteItem := table.aboutToDeleteItem</span><br><span class="line">    table.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger callbacks before deleting an item from cache.</span></span><br><span class="line">    <span class="comment">// 触发删除条数的回调函数</span></span><br><span class="line">    <span class="keyword">if</span> aboutToDeleteItem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, callback := <span class="keyword">range</span> aboutToDeleteItem &#123;</span><br><span class="line">            callback(r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发CacheItem过期删除的回调函数</span></span><br><span class="line">    r.RLock()</span><br><span class="line">    <span class="keyword">defer</span> r.RUnlock()</span><br><span class="line">    <span class="keyword">if</span> r.aboutToExpire != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, callback := <span class="keyword">range</span> r.aboutToExpire &#123;</span><br><span class="line">            callback(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table.Lock()</span><br><span class="line">    table.log(<span class="string">"Deleting item with key"</span>, key, <span class="string">"created on"</span>, r.createdOn, <span class="string">"and hit"</span>, r.accessCount, <span class="string">"times from table"</span>, table.name)</span><br><span class="line">    <span class="built_in">delete</span>(table.items, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete an item from the cache.</span></span><br><span class="line"><span class="comment">//  从缓存表中删除缓存条目， addInternal会释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> table.deleteInternal(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exists returns whether an item exists in the cache. Unlike the Value method</span></span><br><span class="line"><span class="comment">// Exists neither tries to fetch data via the loadData callback nor does it</span></span><br><span class="line"><span class="comment">// keep the item alive in the cache.</span></span><br><span class="line"><span class="comment">//  是否存在某个key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Exists</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    table.RLock()</span><br><span class="line">    <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line">    _, ok := table.items[key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NotFoundAdd tests whether an item not found in the cache. Unlike the Exists</span></span><br><span class="line"><span class="comment">// method this also adds data if they key could not be found.</span></span><br><span class="line"><span class="comment">//  不存在才添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">NotFoundAdd</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, lifeSpan time.Duration, data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, ok := table.items[key]; ok &#123;</span><br><span class="line">        table.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item := NewCacheItem(key, lifeSpan, data)</span><br><span class="line">    table.addInternal(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns an item from the cache and marks it to be kept alive. You can</span></span><br><span class="line"><span class="comment">// pass additional arguments to your DataLoader callback function.</span></span><br><span class="line"><span class="comment">//  获取value, 会通过KeepAlive更新访问时间和访问次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*CacheItem, error)</span></span> &#123;</span><br><span class="line">    table.RLock()</span><br><span class="line">    r, ok := table.items[key]</span><br><span class="line">    loadData := table.loadData</span><br><span class="line">    table.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// Update access counter and timestamp.</span></span><br><span class="line">        r.KeepAlive()</span><br><span class="line">        <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Item doesn't exist in cache. Try and fetch it with a data-loader.</span></span><br><span class="line">    <span class="comment">//  如果不存在，通过loadData获取</span></span><br><span class="line">    <span class="keyword">if</span> loadData != <span class="literal">nil</span> &#123;</span><br><span class="line">        item := loadData(key, args...)</span><br><span class="line">        <span class="keyword">if</span> item != <span class="literal">nil</span> &#123;</span><br><span class="line">            table.Add(key, item.lifeSpan, item.data)</span><br><span class="line">            <span class="keyword">return</span> item, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFoundOrLoadable</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, ErrKeyNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush deletes all items from this cache table.</span></span><br><span class="line"><span class="comment">//  清除所有的缓存条目， 不会调用 缓存表的aboutToDeleteItem 和 缓存条目的aboutToExpire</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">Flush</span><span class="params">()</span></span> &#123;</span><br><span class="line">    table.Lock()</span><br><span class="line">    <span class="keyword">defer</span> table.Unlock()</span><br><span class="line"></span><br><span class="line">    table.log(<span class="string">"Flushing table"</span>, table.name)</span><br><span class="line"></span><br><span class="line">    table.items = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem)</span><br><span class="line">    table.cleanupInterval = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> table.cleanupTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">        table.cleanupTimer.Stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheItemPair maps key to access counter</span></span><br><span class="line"><span class="comment">//  缓存条目对</span></span><br><span class="line"><span class="keyword">type</span> CacheItemPair <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    AccessCount <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheItemPairList is a slice of CacheIemPairs that implements sort.</span></span><br><span class="line"><span class="comment">// Interface to sort by AccessCount.</span></span><br><span class="line"><span class="comment">//  缓存条目对切片</span></span><br><span class="line"><span class="keyword">type</span> CacheItemPairList []CacheItemPair</span><br><span class="line"></span><br><span class="line"><span class="comment">//  qsort需要的一些函数， 根据访问次数排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p CacheItemPairList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i].AccessCount &gt; p[j].AccessCount &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MostAccessed returns the most accessed items in this cache table</span></span><br><span class="line"><span class="comment">//  获取访问最多的几个CacheItem， 最多访问count个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">MostAccessed</span><span class="params">(count <span class="keyword">int64</span>)</span> []*<span class="title">CacheItem</span></span> &#123;</span><br><span class="line">    table.RLock()</span><br><span class="line">    <span class="keyword">defer</span> table.RUnlock()</span><br><span class="line"></span><br><span class="line">    p := <span class="built_in">make</span>(CacheItemPairList, <span class="built_in">len</span>(table.items))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> table.items &#123;</span><br><span class="line">        p[i] = CacheItemPair&#123;k, v.accessCount&#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> r []*CacheItem</span><br><span class="line">    c := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> p &#123;</span><br><span class="line">        <span class="keyword">if</span> c &gt;= count &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item, ok := table.items[v.Key]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            r = <span class="built_in">append</span>(r, item)</span><br><span class="line">        &#125;</span><br><span class="line">        c++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internal logging method for convenience.</span></span><br><span class="line"><span class="comment">//  内部日志打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(table *CacheTable)</span> <span class="title">log</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> table.logger == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table.logger.Println(v...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cache.go</p>  <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Simple caching library with expiration capabilities</span></span><br><span class="line"><span class="comment">*     Copyright (c) 2012, Radu Ioan Fericean</span></span><br><span class="line"><span class="comment">*                   2013-2017, Christian Muehlhaeuser &lt;muesli@gmail.com&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   For license see LICENSE.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cache2go</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 全局缓存表的Map, 支持多个缓存表</span></span><br><span class="line">    cache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*CacheTable)</span><br><span class="line">    <span class="comment">// cache的锁</span></span><br><span class="line">    mutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache returns the existing cache table with given name or creates a new one</span></span><br><span class="line"><span class="comment">// if the table does not exist yet.</span></span><br><span class="line"><span class="comment">//  创建缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cache</span><span class="params">(table <span class="keyword">string</span>)</span> *<span class="title">CacheTable</span></span> &#123;</span><br><span class="line">    mutex.RLock()</span><br><span class="line">    t, ok := cache[table]</span><br><span class="line">    mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        t, ok = cache[table]</span><br><span class="line">        <span class="comment">// Double check whether the table exists or not.</span></span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            t = &amp;CacheTable&#123;</span><br><span class="line">                name:  table,</span><br><span class="line">                items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*CacheItem),</span><br><span class="line">            &#125;</span><br><span class="line">            cache[table] = t</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cache2go是什么&quot;&gt;&lt;a href=&quot;#cache2go是什么&quot; class=&quot;headerlink&quot; title=&quot;cache2go是什么&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/muesli/cache2go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cache2go&lt;/a&gt;是什么&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在github上面的介绍是：Concurrency-safe golang caching library with expiration capabilities.意思是：　具有过期功能并发安全的go语言缓存库。&lt;/p&gt;&lt;h2 id=&quot;注释项目地址&quot;&gt;&lt;a href=&quot;#注释项目地址&quot; class=&quot;headerlink&quot; title=&quot;注释项目地址&quot;&gt;&lt;/a&gt;注释项目地址&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;注释源码见： &lt;a href=&quot;https://github.com/veezhang/cache2go-annotated&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cache2go-annotated&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="【cache2go源码分析】" scheme="https://veezhang.github.io/categories/%E3%80%90cache2go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91/"/>
    
    
      <category term="golang" scheme="https://veezhang.github.io/tags/golang/"/>
    
      <category term="源码分析" scheme="https://veezhang.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="cache2go" scheme="https://veezhang.github.io/tags/cache2go/"/>
    
  </entry>
  
  <entry>
    <title>开篇</title>
    <link href="https://veezhang.github.io/2019/09/03/%E5%BC%80%E7%AF%87/"/>
    <id>https://veezhang.github.io/2019/09/03/开篇/</id>
    <published>2019-09-03T12:50:19.000Z</published>
    <updated>2020-05-13T05:50:25.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么现在开始写博客"><a href="#为什么现在开始写博客" class="headerlink" title="为什么现在开始写博客"></a>为什么现在开始写博客</h2><p>&emsp;&emsp;从毕业开始到现在, 平时工作中也经常会查找一些知识点, 有些记录了, 有些却没有记录, 慢慢的容易忘记, 以前的记录也容易丢失, 所以希望以后在这里记录下来。记录的过程也是巩固的过程, 同时也方便以后回顾。</p><h2 id="主要记录的是什么"><a href="#主要记录的是什么" class="headerlink" title="主要记录的是什么"></a>主要记录的是什么</h2><p>&emsp;&emsp;本博客主要记录一些IT技术, 也可能会记录一些生活。</p><a id="more"></a><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>&emsp;&emsp;一个奋斗在IT界的Coder</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                   _ooOoo_</span><br><span class="line">                  o8888888o</span><br><span class="line">                  <span class="number">88</span><span class="string">" . "</span><span class="number">88</span></span><br><span class="line">                  (| -_- |)</span><br><span class="line">                   O\ = /O</span><br><span class="line">               ____/`---'\____</span><br><span class="line">             .   ' \\| |// `.</span><br><span class="line">              / \\||| : |||<span class="comment">// \</span></span><br><span class="line">            / _||||| -:- |||||- \</span><br><span class="line">              | | \\\ - <span class="comment">/// | |</span></span><br><span class="line">            | \_| ''\---/'' | |</span><br><span class="line">             \ .-\__ `-` ___/-. /</span><br><span class="line">          ___`. <span class="number">.'</span> /--.--\ `. . __</span><br><span class="line">       ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"".</span><br><span class="line">      | | : `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">        \ \ `-. \_ __\ /__ _/ .-` / /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-'======</span><br><span class="line">                   `=---='</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么现在开始写博客&quot;&gt;&lt;a href=&quot;#为什么现在开始写博客&quot; class=&quot;headerlink&quot; title=&quot;为什么现在开始写博客&quot;&gt;&lt;/a&gt;为什么现在开始写博客&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;从毕业开始到现在, 平时工作中也经常会查找一些知识点, 有些记录了, 有些却没有记录, 慢慢的容易忘记, 以前的记录也容易丢失, 所以希望以后在这里记录下来。记录的过程也是巩固的过程, 同时也方便以后回顾。&lt;/p&gt;&lt;h2 id=&quot;主要记录的是什么&quot;&gt;&lt;a href=&quot;#主要记录的是什么&quot; class=&quot;headerlink&quot; title=&quot;主要记录的是什么&quot;&gt;&lt;/a&gt;主要记录的是什么&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本博客主要记录一些IT技术, 也可能会记录一些生活。&lt;/p&gt;
    
    </summary>
    
      <category term="随记" scheme="https://veezhang.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="随记" scheme="https://veezhang.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
